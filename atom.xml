<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Khan</title>
  <icon>https://www.gravatar.com/avatar/9a1a6cad290a9ea462041efbbb5a2212</icon>
  <subtitle>折腾各种技术，痛并快乐着~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ikhan.top/"/>
  <updated>2019-07-15T07:29:07.000Z</updated>
  <id>https://www.ikhan.top/</id>
  
  <author>
    <name>Khan</name>
    <email>clarkhan@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈SOA和微服务</title>
    <link href="https://www.ikhan.top/posts/soa-microservices.html"/>
    <id>https://www.ikhan.top/posts/soa-microservices.html</id>
    <published>2019-06-26T12:11:35.000Z</published>
    <updated>2019-07-15T07:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>近几年，微服务（Microservices）概念火热，在各类技术沙龙、会议上不断被提及。及至当下，很多大厂小司已经有了成功实施案例，也有些正在艰难的摸索过程，或是保持观望。<br>微服务是一种比较“年轻”的架构理念，而在它之前，有类似江湖地位的是SOA（Service Oriented Architecture-面向服务的架构）这位大佬。<br>相信很多小伙伴我一样，在刚接触到微服务概念的时候会不自觉的想到SOA，进而产生一些困惑：它们分别描述的是啥？是不是一种理念的不同表述？如果不同，架构思想是扩大或是聚焦还是存在借鉴重叠，简单来说是有超集或交集的关系？<br>本文将作者的理解与大家分享探讨，尝试对“SOA”和“微服务”的概念做更清晰的解读。</p><a id="more"></a><p><a name="xIN5m"></a></p><h2 id="SOA和微服务是不同的"><a href="#SOA和微服务是不同的" class="headerlink" title="SOA和微服务是不同的"></a>SOA和微服务是不同的</h2><p>我们知道，软件工程和传统工程的显著区别之一是扩展性。为大家熟知的一些建筑工程在历经几百、几千年的风雨后，其建筑架构、功能依然不会偏离最初的设计。而软件项目第一版的交付往往就是第二版改动的开始，甚至第一版设计的时候业务已经对第二版第三版等未来充满了各种美好的设想。</p><p>而SOA和微服务都是在解决扩展性问题的过程中对可扩展软件架构的一种模式的思想总结。它们应对“可扩展”这个问题的的拆分方式都是“面向服务拆分”。这也是我们很难区分它们的原因之一。</p><p>我的观点是，“SOA和微服务是不同的”。“SOA”的概念要远远早于“微服务”的概念出现，从它们出现的历史背景和最初要解决的问题，可以发现它们架构思想的主要区别。<br><a name="g1uTV"></a></p><h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><p>1996年，Gartner公司最早提出了SOA的概念<br>2000年之后，基于XML的WEB服务协议（soap、wsdl、uddi）和标准促进SOA发展<br>2002年12月，Gartner提出了SOA是“现代应用开发领域最重要的课题”<br>2005年后，soa推广和普及工作加速，各大厂商通过协作组织开始合作制定soa标准，涉及后续的sca、sdo、ws-policy</p><p>可以看到SOA的概念在很久前就被提出了，而当时并不是如当下的互联网蓬勃发展期。其背景是传统企业内部的各个IT系统中有大量重复建设工作，系统扩展困难，用于IT整合的预算占比太过庞大。比如，营销、财务、生产、办公等各个系统可能采购于不同的厂商，各自都有独立的人员管理等功能。企业又希望信息能够在各个系统间互通，需要这些异构系统大量的集成改造工作。</p><p>为了更好的解决这些问题，SOA中有几个核心概念：<strong>服务</strong>、<strong>松耦合</strong> 、<strong>ESB</strong>（Enterprise service bus-企业服务总线）。我们来看一个典型的架构图来理解SOA的核心概念：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1561700389777-e658b73f-ac55-41bf-8f6c-b0afe48101a3.png?x-oss-process=image/resize,w_578#align=left&display=inline&height=407&originHeight=407&originWidth=578&status=done&width=578" alt><br>（图片来自于网络）</p><p>SOA的架构中，原各个系统通过可以被ESB理解的协议开放自己的系统功能作为服务，或者使用其他系统开放的服务。ESB屏蔽各个系统间的异构性，并有公共的服务路由、异常处理、协议转换等功能，满足不同系统服务间的互联互通。各个服务间要尽量的松耦合，降低互相依赖和影响。</p><p>将系统功能通过协议暴露为服务不算复杂。松耦合就是对服务的业务设计层面解耦要求。但是技术层面，实现SOA架构的重任主要都在ESB上面。它要求ESB全知全能，协议转换更是要求对HTTP、WS、RPC、JMS等协议，XML、JSON、HTML、二进制等数据格式通通都能够解析和转换。其工作量、复杂度、计算量要求都很高，尤其当参与的系统增多，消息量愈大的时候，ESB往往成为架构瓶颈，也是SOA架构中被诟病的点。</p><p>之所以有ESB这样的设计，也是现实的无奈。正如我们上面提到的背景所述，企业IT系统中往往有很多的遗留系统，采购自不同的厂商，各家企业完全去重写或改造的成本非常巨大,自然而然，需要引入ESB这样的中间件作为核心的解决方案。</p><p>Gartner公司当初曾预言，“预计到2009年，SOA将成为占有绝对优势的软件工程实践方法， 2008年全球将有近7成企业导入SOA”。而实际上，在08、09年，各家厂商联合制定的soa标准趋于成熟的阶段，它们（厂商）预想的SOA在互联网企业中的应用依然很少，更多的是借鉴一些概念和思路。主要的应用还是在传统行业。</p><p><a name="wZjdk"></a></p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>现在普遍认为微服务是由Martin Fowler 与 James Lewis 在2014年提出来的。实际上微服务这几年的兴起的确主要归功于两位大师在14的合写的<a href="https://martinfowler.com/articles/microservices.html" rel="external nofollow noopener noreferrer" target="_blank">文章</a>，其中详细阐述了微服务的概念。Google Trends也很明显，在14年后，“microservices”一词热度上升趋势明显。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1562749400534-25d936a5-157b-4c29-aade-01f3bedd1806.png#align=left&display=inline&height=228&name=image.png&originHeight=251&originWidth=1115&size=22570&status=done&width=1013.6363416663876" alt="image.png"><br>但是向前追溯的话，早在2005年Peter Rodgers在Web Services Edge大会上就提到了“Micro-Web-Services”的概念，在11和12年，一个软件架构工作组就直接使用了“microservice”这个词来描述架构模式了。12年3月ThoughtWorks的James Lewis分享了一些关于微服务的想法。</p><p>可见，微服务这种架构是也是历经很多年的演进，在一个适当时机由Martin Fowler在文章中明确定义被被大家广泛熟知。在Martin Fowler的这篇原文 <a href="https://martinfowler.com/articles/microservices.html" rel="external nofollow noopener noreferrer" target="_blank">https://martinfowler.com/articles/microservices.html</a> 中，开篇就说明了此事：</p><blockquote><p><em>The term “Microservice Architecture” has sprung up over the last few years to describe a particular way of designing software applications as suites of independently deployable services. While there is no precise definition of this architectural style, there are certain common characteristics around organization around business capability, automated deployment, intelligence in the endpoints, and decentralized control of languages and data.</em></p></blockquote><p>而关于微服务，文中的定义为:</p><blockquote><p>In short, the microservice architectural style <a href="https://martinfowler.com/articles/microservices.html#footnote-etymology" rel="external nofollow noopener noreferrer" target="_blank">[1]</a> is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</p></blockquote><p>把上面的定义简单翻译如下：<br>简而言之，微服务架构风格是将<strong>单应用开发分为一组小的服务</strong>，每个服务运行在独立的进程中，并使用<strong>轻量级</strong>的机制（通常是HTTP资源API）通讯。这些服务围绕业务功能构建，并通过<strong>自动化的部署</strong>机制被独立部署。这些服务可以用不同的编程语言编写，使用不同的数据存储技术，只需要最低限度的集中管理。</p><p>（下面引用流传甚广的一个单体应用和微服务应用架构的对比图，方便直观理解）。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1562837436282-4aaafbba-438c-4859-a122-ac7689f06c5f.png#align=left&display=inline&height=547&name=image.png&originHeight=602&originWidth=969&size=151049&status=done&width=880.909071815901" alt="image.png"></p><p>Martin Fowler对微服务的定义可以说简单清晰，典型的面向服务拆分的架构。但要弄清楚和SOA的区别需要特别注意几点：</p><p>首先，微服务考虑的核心场景是将单体应用开发拆分为一组小的服务。是解决业务场景愈来愈复杂的情况下，单体应用不仅业务过重架构难以保持良好模块清晰，同时人员配合困难、变更应用影响太大，无法匹配业务发展等问题。这些问题在快速发展的互联网企业架构中愈来愈凸显。</p><p>其次，微服务间的通讯要求轻量级，各种服务采用相同的，通用的协议。Martin Fowler 文章中有一节的标题即“Smart endpoints and dumb pipes”（智能端点和愚蠢的管道/富终端瘦通信），并用 ESB做了对比。微服务推崇的消息通讯仅根据约定的协议做消息传输，其他依赖的各项功能由客户端或客户端使用其他更“纯粹”的中间件各自负责。</p><p>更重要的，微服务围绕单应用中业务功能的细粒度的拆分强依赖于自动化的部署机制，也可以讲很是依赖于现代的DevOps 基础设施。微服务之所以可以在近些年有很多成功案例并火热，也得益于容器化、DevOps的发展，否则要求快速响应，持续交付，细粒度拆分且不断增长的微服务应用对开发、部署、测试、上线等流程就是无底深渊。</p><p>总结来讲，不同于SOA为了应对传统IT企业的多系统集成场景，微服务从高速发展的互联网单体应用拆分场景演进而来，架构思想的出发点不同，形似但神不似；不同于SOA由各大厂商主推，核心解决方案中主要的产品ESB做服务间通讯，微服务倾向于简单统一的协议，简单纯粹。可以直接采用HTTP或采用开源方案甚至自己实现，也不必向厂商购买重量级的中间件产品；不同于SOA主要关注与系统集成、通讯等技术层面，微服务思想本身包括了团队组织、基础设施等DevOps领域的理念，并且不可或缺。</p><p><a name="OuQXC"></a></p><h2 id="微服务和SOA是承继的"><a href="#微服务和SOA是承继的" class="headerlink" title="微服务和SOA是承继的"></a>微服务和SOA是承继的</h2><p>上一节，我们从SOA和微服务的历史背景和最初要解决的问题，相对严格的将SOA和微服务思想的差异做了分析。此节，我们再来看看他们之间的关联。</p><p>其实，从上一节的内容中我们都能体会到，两种架构的核心思想中很重要的一点，都是面向“服务”进行可扩展的设计。微服务概念出现的土壤也是SOA中这种“服务化”的思想已经深入人心，并且这种思想被更彻底贯彻在微服务理念中。所以，目前很多人认为微服务就是SOA实现的一种，甚至称之为“细粒度的SOA”。不讲绝对意义上的是或不是，总归，微服务承继了SOA的核心理念的主要部分是没错的。</p><p>上文也提到，SOA中的ESB被广为诟病，它是在那当时特定场景下一种解决方案。随着发展，在更多新的场景中，ESB并无必要，加之一些弊端，自然而然就被新的方式替代，也就是现在的“富终端瘦通信”。所以，从历史来看，微服务是慢慢从SOA演化而来，去掉其中的ESB，也没错。</p><p>在SOA架构思想向微服务演化过程中，容器化相关技术高速发展，DevOps也愈来愈火热。应用运行环境可以整体打包交付，资源调度简单高效，自动化智能化的部署、监控运维在愈来愈多的场景中实施。这些使得服务更微型化，并作为应用被自动化独立部署，需要人工参与管理却更少，这些都变的可行和合理。自然，面向服务的拆分思想吸收了营养后生长也就更加“野蛮”、“激进”。所以，不仅新理念中在服务粒度上可以更“微”，也考虑了在这种架构中开发组织和基础设施的一些转变。</p><p>总结来讲，就是微服务承继了SOA面向服务拆分的核心思想，并随着演化，去掉了ESB，结合了新兴的DevOps理念和容器化等基础设施发展优势，将服务拆分做的更彻底。所以他们的关系大概如下，是交集的关系。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1562912850396-c18579c1-fd81-42d9-bcf1-b7e83404d06a.png#align=left&display=inline&height=97&name=SOA%20%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1.png&originHeight=97&originWidth=341&size=7230&status=done&width=341" alt="SOA 和微服务.png"><br>微服务既然可以说是从SOA演化而来，将其定义为新的，特殊的SOA也并无不可，通常来讲，现在大家说的SOA也不是特指最初的狭义的SOA概念了。但毕竟微服务和最初的SOA理念方向有差异，在演化到一个新的阶段有明确的区分后，使用新的名词作也很合理。相信我们在搞清楚其差异和联系后，就不用过于纠结两个名词是否一个含义了。<br><br><br>本文只是讲述了作者自己的理解，难免会有错漏，欢迎留言讨论。作者在接触相关概念至今参考了很多朋友的资料文章，难以在此处清晰细致的一一回忆，就在此一并感谢所有愿意分享的同行。谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近几年，微服务（Microservices）概念火热，在各类技术沙龙、会议上不断被提及。及至当下，很多大厂小司已经有了成功实施案例，也有些正在艰难的摸索过程，或是保持观望。&lt;br&gt;微服务是一种比较“年轻”的架构理念，而在它之前，有类似江湖地位的是SOA（Service Oriented Architecture-面向服务的架构）这位大佬。&lt;br&gt;相信很多小伙伴我一样，在刚接触到微服务概念的时候会不自觉的想到SOA，进而产生一些困惑：它们分别描述的是啥？是不是一种理念的不同表述？如果不同，架构思想是扩大或是聚焦还是存在借鉴重叠，简单来说是有超集或交集的关系？&lt;br&gt;本文将作者的理解与大家分享探讨，尝试对“SOA”和“微服务”的概念做更清晰的解读。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="https://www.ikhan.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="soa" scheme="https://www.ikhan.top/tags/soa/"/>
    
      <category term="microservices" scheme="https://www.ikhan.top/tags/microservices/"/>
    
  </entry>
  
  <entry>
    <title>Pods 无法通过 Service 访问自己</title>
    <link href="https://www.ikhan.top/posts/pod-can-not-traffic-to-isself-via-service.html"/>
    <id>https://www.ikhan.top/posts/pod-can-not-traffic-to-isself-via-service.html</id>
    <published>2019-05-27T11:39:35.000Z</published>
    <updated>2019-05-28T06:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你尝试在Kubernetes Pod中通过Service访问自己，但失败了，请看本文。</p><a id="more"></a><p><a name="5Fw4i"></a></p><h2 id="官方文档相关问题参考"><a href="#官方文档相关问题参考" class="headerlink" title="官方文档相关问题参考"></a>官方文档相关问题参考</h2><blockquote><p>如果你是用的是 minikube，可以跳过这一段，直接看下面。</p></blockquote><p>官方文档的Tasks中，《Debug Service》这一篇有 <a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-service/#a-pod-cannot-reach-itself-via-service-ip" rel="external nofollow noopener noreferrer" target="_blank">A Pod cannot reach itself via Service IP</a> 一节，讲了这种情况。主要意思就是我们的网络没有正确配置 <code>hairpin-mode</code> ，这个参数是在 <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" rel="external nofollow noopener noreferrer" target="_blank"><code>kubelet</code></a><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" rel="external nofollow noopener noreferrer" target="_blank"> </a>上的。可以通过在node上运行如下的命令，是不是有相关配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps auxw|grep kubelet</span><br></pre></td></tr></table></figure><p>后续的问题可以参照官方文档中解决。整段翻译如下：</p><blockquote><p>TODO,暂时貌似不需要。如果需要翻译，可以回复。</p></blockquote><p><a name="GLeMn"></a></p><h2 id="Minikube-解决"><a href="#Minikube-解决" class="headerlink" title="Minikube 解决"></a>Minikube 解决</h2><p>minikube 只需要执行下面这行命令，设置集群所在虚拟的docker网卡就OK了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube ssh -- sudo ip link <span class="built_in">set</span> docker0 promisc on</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你尝试在Kubernetes Pod中通过Service访问自己，但失败了，请看本文。&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://www.ikhan.top/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="k8s" scheme="https://www.ikhan.top/tags/k8s/"/>
    
      <category term="kubernetes" scheme="https://www.ikhan.top/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>K8S互动教程4-使用服务发布您的应用程序</title>
    <link href="https://www.ikhan.top/posts/qrqc-basic-k8s-interactive-tutorial-4.html"/>
    <id>https://www.ikhan.top/posts/qrqc-basic-k8s-interactive-tutorial-4.html</id>
    <published>2019-05-26T11:39:35.000Z</published>
    <updated>2019-05-28T07:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《浅入浅出k8s实战-k8s初体验篇的第五篇 》</p><p>此文为提取大纲，按照互动教程进行分享教学用。另补充一些知识点，和关联操作。</p><p>原文：</p><ul><li>中：<a href="https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/expose-intro/" rel="external nofollow noopener noreferrer" target="_blank">https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/expose-intro/</a></li><li>英：<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/" rel="external nofollow noopener noreferrer" target="_blank">https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/</a></li><li>互动：<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-interactive/" rel="external nofollow noopener noreferrer" target="_blank">https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-interactive/</a></li></ul><p><a name="nysyV"></a></p><h2 id="课程说明"><a href="#课程说明" class="headerlink" title="课程说明"></a>课程说明</h2><p><a name="g0oq9"></a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>了解 Kubernetes Service（服务）</li><li>了解 labels 和 LabelSelector 对象如何与 Service 关联</li><li>通过 Service 将应用暴露到集群外部</li></ul><a id="more"></a><p><a name="b9NpW"></a></p><h3 id="操作内容"><a href="#操作内容" class="headerlink" title="操作内容"></a>操作内容</h3><ul><li>创建新的服务</li><li>使用Labels</li><li>删除Service</li></ul><p><a name="IUgxn"></a></p><h3 id="Kubernetes-Service-概述"><a href="#Kubernetes-Service-概述" class="headerlink" title="Kubernetes Service 概述"></a>Kubernetes Service 概述</h3><p>Kubernetes Pods 不是永久存在的，它有一个<a href="https://www.ikhan.top/posts/k8s-concepts-pod-lifecyle.html">生命周期</a>。当一个工作Node宕机是，运行在这个Node上的Pods也会丢失。<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" rel="external nofollow noopener noreferrer" target="_blank">ReplicatSet</a> 可能会通过创建新的Pod，动态地调度集群使之恢复到目标状态来保证您的应用继续运行。比如说，有个拥有3个副本的图形处理后端程序，这些副本是可以被替换的（简单理解为无状态的）。其前端系统不应该关心后端的副本情况，即使副本的Pod丢失后被重建。Kubernetes集群中每一个Pod有一个独立的IP，即使在同一个Node上也是这样，这样的话我们就需要一种能够<strong>自动应对Pod间变化</strong>的机制来保证我们的程序能持续的运行。</p><p>Kubernetes 中的Service是一个抽象资源，它定义了一组Pod的逻辑集合和<strong>通过Service访问这些Pod的策略</strong>。Services支持有依赖关系的Pods松耦合。Service 像所有Kubernetes对象一样，支持使用Yaml（推荐）或JSON。Service 指向的一组Pods通常<strong>由 LabelSelector 指定</strong>（为什么你可能不想要在Service 的 spce 中包含 <code>selector</code> 请参见下文）。</p><p>尽管每个Pod都有一个唯一的IP地址，但不通过Service这些IP不会被暴露到集群外部（一般意义上是这样，但存在网络互通方案）。Services允许你的应用接收流量。通过指定ServiceSpec中的 <code>type</code> 字段，Services可以被不同的方式<strong>暴露</strong>：</p><ul><li>ClusterIP（默认）- 在集群内部IP上暴露Service。这种方式Service只能在集群内部被访问。</li><li>NodePort - 通过NAT在每个选中（未找到限定方式，应该是所有Node？）Node上的相同端口暴露Service。使一个Service可以通过 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 的形式从外部访问，这种方式是 ClusterIP 的超集。</li><li>LoadBalancer - 在当前云平台创建外部的负载均衡器（如果支持的话） ，并为Service分配一个固定的集群外部IP，是NodePort的超集。</li><li>ExternalName - 使用任意的名称暴露Service（通过spec的 <code>externalName</code> 指定），其行为是返回使用这个名称的CNAME记录。无需使用代理。这种方式要求 V1.7或更高版本的 <code>kube-dns</code> 。</li></ul><p>关于不同类型 Services 的更多信息，可以参见<a href="https://kubernetes.io/docs/tutorials/services/source-ip/" rel="external nofollow noopener noreferrer" target="_blank">Using Source IP</a>教程和<a href="https://kubernetes.io/docs/concepts/services-networking/connect-applications-service" rel="external nofollow noopener noreferrer" target="_blank">Connecting Applications with Services</a>。<br>另外，需要注意的是有些情况下Services不在spec中定义 <code>selector</code> 。没有 <code>selector</code> 定义创建的Service也不会创建相应的端点（Endpoints）。这样用户可以手动映射Service到特定的endpoints。另外一种没有selector的情况是严格用了 <code>type: ExternalName</code> 类型的Service。<br><a name="g6eHG"></a></p><h3 id="服务和标签"><a href="#服务和标签" class="headerlink" title="服务和标签"></a>服务和标签</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/svg/328984/1558947695592-a71ad54b-2675-40f1-9b68-d9b4e2ae8fee.svg#align=left&display=inline&height=514&originHeight=440&originWidth=394&size=0&status=done&width=460" alt><br>服务可以路由流量到一组Pods上。服务是一个抽象资源，允许Kubernetes中Pod在宕掉和复制的情况下不对应用造成冲击。有依赖关系的Pods间（比如一个应用的前端和后端组件）发现和路由通过Kubernetes Services处理。</p><p>Services使用<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels" rel="external nofollow noopener noreferrer" target="_blank">labels and selectors</a>匹配一组Pods。lables和selectors是Kubernetes可以在对象上进行逻辑运算的分组原语。Labels 是附加到对象上的键值对，会在多种场景中被使用：</p><ul><li>指定和区分对象是开发、测试还是生产环境</li><li>嵌入版本号</li><li>用标签（tags）分类对象<blockquote><p>你可以使用kubectl 的 <code>--expose</code> 参数，在创建 Deployment 的同时创建 Service。</p></blockquote></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/svg/328984/1558948479829-92590b36-e40f-469c-80fa-e4f4d621c65a.svg#align=left&display=inline&height=528&originHeight=150&originWidth=134&size=0&status=done&width=470" alt><br>Labels 可以创建对象的时候或之后附加到对象上。可以在任何时候被修改。我们一起使用Service暴露我么的应用，并应用一些labels吧。<br><a name="I7Mqr"></a></p><h2 id="互动教程"><a href="#互动教程" class="headerlink" title="互动教程"></a>互动教程</h2><p><a name="1o6XR"></a></p><h3 id="创建新的服务"><a href="#创建新的服务" class="headerlink" title="创建新的服务"></a>创建新的服务</h3><p>我们先看下基于<a href="https://www.ikhan.top/posts/qrqc-basic-k8s-interactive-tutorial-3.html">上一节</a>之后我们系统里有哪些Pods：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">first-deploy-whoami-68dd7db55-bpr52   1/1     Running   0          4d1h</span><br></pre></td></tr></table></figure><p>然后再看看已有的 Services：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   10d</span><br></pre></td></tr></table></figure><p>我们可以看到一个已经存在的名叫kubernetes的服务，这个是minikube在集群启动的时候自动创建的。这个是 API Server 的 Service。非 minikube 创建的集群default namespace下也有。</p><p>我们来创建如下几个不同的 Service：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment first-deploy-whoami --name first-deploy-whoami-svc-1 --<span class="built_in">type</span> LoadBalancer --port 8080 --target-port 80</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment first-deploy-whoami --name first-deploy-whoami-svc-2 --<span class="built_in">type</span> NodePort --port 80</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment first-deploy-whoami --name first-deploy-whoami-svc-3 --<span class="built_in">type</span> ClusterIP --port 8080 --target-port 80</span><br></pre></td></tr></table></figure><p>我们使用的方式是暴露我们前两节创建的 deployment 对应的 Pods。 <code>--name</code> 后就是我们指定的 Service name， <code>--type</code> 是指定Service的暴露方式。 <code>--port</code> 是Service对外服务的端口。 <code>--target-port</code> 是Service映射的Endpoints 端口部分（Pods的对外服务端口）。需要注意的是，如果<code>--port</code> 或 <code>--target-port</code> 没有指定，将默认取另一项的值。都没指定则取Pods暴露的端口。</p><p>当然， <code>expose</code> 可以将很多kubernetes资源对应的Pods暴露为服务，包含：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod (po),<span class="built_in"> service </span>(svc), replicationcontroller (rc), deployment (deploy), replicaset (rs)</span><br></pre></td></tr></table></figure><p>我们之前暴露的几个服务通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></table></figure><p>和 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe services first-deploy-whoami-svc-1 first-deploy-whoami-svc-2 first-deploy-whoami-svc-3</span><br></pre></td></tr></table></figure><p>来看一下。着重关注IP，Port，TargetPort，NodePort和 Endpoints字段。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">➜</span>  <span class="string">clark</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">services</span></span><br><span class="line"><span class="string">NAME</span>                        <span class="string">TYPE</span>           <span class="string">CLUSTER-IP</span>     <span class="string">EXTERNAL-IP</span>   <span class="string">PORT(S)</span>          <span class="string">AGE</span></span><br><span class="line"><span class="string">first-deploy-whoami-svc-1</span>   <span class="string">LoadBalancer</span>   <span class="number">10.103</span><span class="number">.234</span><span class="number">.1</span>   <span class="string">&lt;pending&gt;</span>     <span class="number">8080</span><span class="string">:30095/TCP</span>   <span class="string">18h</span></span><br><span class="line"><span class="string">first-deploy-whoami-svc-2</span>   <span class="string">NodePort</span>       <span class="number">10.102</span><span class="number">.32</span><span class="number">.78</span>   <span class="string">&lt;none&gt;</span>        <span class="number">80</span><span class="string">:31502/TCP</span>     <span class="string">18h</span></span><br><span class="line"><span class="string">first-deploy-whoami-svc-3</span>   <span class="string">ClusterIP</span>      <span class="number">10.101</span><span class="number">.43</span><span class="number">.23</span>   <span class="string">&lt;none&gt;</span>        <span class="number">8080</span><span class="string">/TCP</span>         <span class="string">18h</span></span><br><span class="line"><span class="string">kubernetes</span>                  <span class="string">ClusterIP</span>      <span class="number">10.96</span><span class="number">.0</span><span class="number">.1</span>      <span class="string">&lt;none&gt;</span>        <span class="number">443</span><span class="string">/TCP</span>          <span class="string">11d</span></span><br><span class="line"><span class="string">➜</span>  <span class="string">clark</span> <span class="string">kubectl</span> <span class="string">describe</span> <span class="string">services</span> <span class="string">first-deploy-whoami-svc-1</span> <span class="string">first-deploy-whoami-svc-2</span> <span class="string">first-deploy-whoami-svc-3</span></span><br><span class="line"><span class="attr">Name:</span>                     <span class="string">first-deploy-whoami-svc-1</span></span><br><span class="line"><span class="attr">Namespace:</span>                <span class="string">default</span></span><br><span class="line"><span class="attr">Labels:</span>                   <span class="string">run=first-deploy-whoami</span></span><br><span class="line"><span class="attr">Annotations:</span>              <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Selector:</span>                 <span class="string">run=first-deploy-whoami</span></span><br><span class="line"><span class="attr">Type:</span>                     <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">IP:</span>                       <span class="number">10.103</span><span class="number">.234</span><span class="number">.1</span></span><br><span class="line"><span class="attr">Port:</span>                     <span class="string">&lt;unset&gt;</span>  <span class="number">8080</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">TargetPort:</span>               <span class="number">80</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">NodePort:</span>                 <span class="string">&lt;unset&gt;</span>  <span class="number">30095</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">Endpoints:</span>                <span class="number">172.17</span><span class="number">.0</span><span class="number">.5</span><span class="string">:80</span></span><br><span class="line"><span class="attr">Session Affinity:</span>         <span class="string">None</span></span><br><span class="line"><span class="attr">External Traffic Policy:</span>  <span class="string">Cluster</span></span><br><span class="line"><span class="attr">Events:</span>                   <span class="string">&lt;none&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">Name:</span>                     <span class="string">first-deploy-whoami-svc-2</span></span><br><span class="line"><span class="attr">Namespace:</span>                <span class="string">default</span></span><br><span class="line"><span class="attr">Labels:</span>                   <span class="string">run=first-deploy-whoami</span></span><br><span class="line"><span class="attr">Annotations:</span>              <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Selector:</span>                 <span class="string">run=first-deploy-whoami</span></span><br><span class="line"><span class="attr">Type:</span>                     <span class="string">NodePort</span></span><br><span class="line"><span class="attr">IP:</span>                       <span class="number">10.102</span><span class="number">.32</span><span class="number">.78</span></span><br><span class="line"><span class="attr">Port:</span>                     <span class="string">&lt;unset&gt;</span>  <span class="number">80</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">TargetPort:</span>               <span class="number">80</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">NodePort:</span>                 <span class="string">&lt;unset&gt;</span>  <span class="number">31502</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">Endpoints:</span>                <span class="number">172.17</span><span class="number">.0</span><span class="number">.5</span><span class="string">:80</span></span><br><span class="line"><span class="attr">Session Affinity:</span>         <span class="string">None</span></span><br><span class="line"><span class="attr">External Traffic Policy:</span>  <span class="string">Cluster</span></span><br><span class="line"><span class="attr">Events:</span>                   <span class="string">&lt;none&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">Name:</span>              <span class="string">first-deploy-whoami-svc-3</span></span><br><span class="line"><span class="attr">Namespace:</span>         <span class="string">default</span></span><br><span class="line"><span class="attr">Labels:</span>            <span class="string">run=first-deploy-whoami</span></span><br><span class="line"><span class="attr">Annotations:</span>       <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Selector:</span>          <span class="string">run=first-deploy-whoami</span></span><br><span class="line"><span class="attr">Type:</span>              <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">IP:</span>                <span class="number">10.101</span><span class="number">.43</span><span class="number">.23</span></span><br><span class="line"><span class="attr">Port:</span>              <span class="string">&lt;unset&gt;</span>  <span class="number">8080</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">TargetPort:</span>        <span class="number">80</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">Endpoints:</span>         <span class="number">172.17</span><span class="number">.0</span><span class="number">.5</span><span class="string">:80</span></span><br><span class="line"><span class="attr">Session Affinity:</span>  <span class="string">None</span></span><br><span class="line"><span class="attr">Events:</span>            <span class="string">&lt;none&gt;</span></span><br></pre></td></tr></table></figure><ul><li>IP 就是集群内的IP</li><li>Port和TargetPort上面介绍过，对应 <code>--port</code> 和 <code>--target-port</code> </li><li>NodePort通过命令的方式未能找到指定的参数（如果发现请留言告诉我），但YAML等方式可以指定。所以此处不指定会默认从30000-32767中随机一个端口，这个随机范围可以在API server的配置文件中，用–service-node-port-range定义。</li><li>Endpoints 就是Service映射的Pod ip+port 了，会根据Pod情况动态变化。</li></ul><p>根据我们创建的不同Service类型，也可以印证我们之前提到的“超集”概念。LoadBalancer 包含 NodePort 包含 ClusterIP。</p><p>minikube 并不支持 <code>LoadBalancer</code> 类型的Service，所以其 <code>External-IP</code> 一直是 <code>&lt;pending&gt;</code> 状态。对于有node port的Service，minikube 可以通过 <code>service</code> 命令来在浏览器打开或者显示其访问地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube.exe service first-deploy-whoami-svc-1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube.exe service first-deploy-whoami-svc-2 --url</span><br></pre></td></tr></table></figure><p>也可以列出所有的Service的访问地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  clark minikube.exe service list                                        </span><br><span class="line">|-------------|---------------------------|-----------------------------| </span><br><span class="line">|  NAMESPACE  |           NAME            |             URL             | </span><br><span class="line">|-------------|---------------------------|-----------------------------| </span><br><span class="line">| default     | first-deploy-whoami-svc-1 | http://192.168.99.101:30095 | </span><br><span class="line">| default     | first-deploy-whoami-svc-2 | http://192.168.99.101:31502 | </span><br><span class="line">| default     | first-deploy-whoami-svc-3 | No node port                | </span><br><span class="line">| default     | kubernetes                | No node port                | </span><br><span class="line">| kube-system | kube-dns                  | No node port                | </span><br><span class="line">| kube-system | kubernetes-dashboard      | No node port                | </span><br><span class="line">|-------------|---------------------------|-----------------------------|</span><br></pre></td></tr></table></figure><p>通过上面的地址，你应该可以访问到Pod的应用，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  clark curl http://192.168.99.101:30095/</span><br><span class="line">Hostname: first-deploy-whoami-68dd7db55-8rhd2</span><br><span class="line">IP: 127.0.0.1</span><br><span class="line">IP: 172.17.0.5</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 192.168.99.101:30095</span><br><span class="line">User-Agent: curl/7.58.0</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><p>我们可以尝试在集群中访问这几个服务，启动新的一次性Pods访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run <span class="built_in">test</span>-service-pod -it --rm --restart=Never --image=busybox --port=80 --generator=run-pod/v1 -- wget -q -O - http://first-deploy-whoami-svc-1:8080</span><br></pre></td></tr></table></figure><p>如果你想在Service映射的Pod中通过Service访问Pod自己，可能会遇到无法访问的情况，请参照这篇文章：<br><a href="https://www.ikhan.top/posts/pod-can-not-traffic-to-isself-via-service.html">Pods 无法通过 Service 访问自己</a>。</p><p><a name="QB5vB"></a></p><h3 id="使用-Labels"><a href="#使用-Labels" class="headerlink" title="使用 Labels"></a>使用 Labels</h3><p>复习获取 deployments 的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe deployments</span><br></pre></td></tr></table></figure><p>我们可以看到类似的输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">➜</span>  <span class="string">clark</span> <span class="string">kubectl</span> <span class="string">describe</span> <span class="string">deployments</span>                                                                              </span><br><span class="line"><span class="attr">Name:</span>                   <span class="string">first-deploy-whoami</span>                                                                        </span><br><span class="line"><span class="attr">Namespace:</span>              <span class="string">default</span>                                                                                    </span><br><span class="line"><span class="attr">CreationTimestamp:</span>      <span class="string">Tue,</span> <span class="number">28</span> <span class="string">May</span> <span class="number">2019</span> <span class="number">13</span><span class="string">:20:39</span> <span class="string">+0800</span>                                                            </span><br><span class="line"><span class="attr">Labels:</span>                 <span class="string">run=first-deploy-whoami</span>                                                                    </span><br><span class="line"><span class="attr">Annotations:            deployment.kubernetes.io/revision:</span> <span class="number">1</span>                                                       </span><br><span class="line"><span class="attr">Selector:</span>               <span class="string">run=first-deploy-whoami</span>                                                                    </span><br><span class="line"><span class="attr">Replicas:</span>               <span class="number">1</span> <span class="string">desired</span> <span class="string">|</span> <span class="number">1</span> <span class="string">updated</span> <span class="string">|</span> <span class="number">1</span> <span class="string">total</span> <span class="string">|</span> <span class="number">1</span> <span class="string">available</span> <span class="string">|</span> <span class="number">0</span> <span class="string">unavailable</span>                              </span><br><span class="line"><span class="attr">StrategyType:</span>           <span class="string">RollingUpdate</span>                                                                              </span><br><span class="line"><span class="attr">MinReadySeconds:</span>        <span class="number">0</span>                                                                                          </span><br><span class="line"><span class="attr">RollingUpdateStrategy:</span>  <span class="number">25</span><span class="string">%</span> <span class="string">max</span> <span class="string">unavailable,</span> <span class="number">25</span><span class="string">%</span> <span class="string">max</span> <span class="string">surge</span>                                                         </span><br><span class="line"><span class="attr">Pod Template:</span>                                                                                                      </span><br><span class="line">  <span class="attr">Labels:</span>  <span class="string">run=first-deploy-whoami</span>                                                                                 </span><br><span class="line">  <span class="attr">Containers:</span>                                                                                                      </span><br><span class="line">   <span class="attr">first-deploy-whoami:</span>                                                                                            </span><br><span class="line">    <span class="attr">Image:</span>        <span class="string">registry.cn-hangzhou.aliyuncs.com/khan/whoami:1.0</span>                                                </span><br><span class="line">    <span class="attr">Port:</span>         <span class="number">80</span><span class="string">/TCP</span>                                                                                           </span><br><span class="line">    <span class="attr">Host Port:</span>    <span class="number">0</span><span class="string">/TCP</span>                                                                                            </span><br><span class="line">    <span class="attr">Environment:</span>  <span class="string">&lt;none&gt;</span>                                                                                           </span><br><span class="line">    <span class="attr">Mounts:</span>       <span class="string">&lt;none&gt;</span>                                                                                           </span><br><span class="line">  <span class="attr">Volumes:</span>        <span class="string">&lt;none&gt;</span>                                                                                           </span><br><span class="line"><span class="attr">Conditions:</span>                                                                                                        </span><br><span class="line">  <span class="string">Type</span>           <span class="string">Status</span>  <span class="string">Reason</span>                                                                                    </span><br><span class="line">  <span class="string">----</span>           <span class="string">------</span>  <span class="string">------</span>                                                                                    </span><br><span class="line">  <span class="string">Available</span>      <span class="literal">True</span>    <span class="string">MinimumReplicasAvailable</span>                                                                  </span><br><span class="line">  <span class="string">Progressing</span>    <span class="literal">True</span>    <span class="string">NewReplicaSetAvailable</span>                                                                    </span><br><span class="line"><span class="attr">OldReplicaSets:</span>  <span class="string">&lt;none&gt;</span>                                                                                            </span><br><span class="line"><span class="attr">NewReplicaSet:</span>   <span class="string">first-deploy-whoami-68dd7db55</span> <span class="string">(1/1</span> <span class="string">replicas</span> <span class="string">created)</span>                                              </span><br><span class="line"><span class="attr">Events:</span>                                                                                                            </span><br><span class="line">  <span class="string">Type</span>    <span class="string">Reason</span>             <span class="string">Age</span>   <span class="string">From</span>                   <span class="string">Message</span>                                                  </span><br><span class="line">  <span class="string">----</span>    <span class="string">------</span>             <span class="string">----</span>  <span class="string">----</span>                   <span class="string">-------</span>                                                  </span><br><span class="line">  <span class="string">Normal</span>  <span class="string">ScalingReplicaSet</span>  <span class="string">10m</span>   <span class="string">deployment-controller</span>  <span class="string">Scaled</span> <span class="string">up</span> <span class="string">replica</span> <span class="string">set</span> <span class="string">first-deploy-whoami-68dd7db55</span> <span class="string">to</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到其中有如下两行：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pod Template:                                                                                                      </span><br><span class="line">  Labels:  <span class="built_in">run</span>=<span class="keyword">first</span>-deploy-whoami</span><br></pre></td></tr></table></figure><p>我们尝试用这个 Labels 获取 Pods：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  clark kubectl get pods -l run=first-deploy-whoami</span><br><span class="line">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">first-deploy-whoami-68dd7db55-qtfdq   1/1     Running   0          12m</span><br></pre></td></tr></table></figure><p>同样用这个 Labels 获取 Services：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  clark kubectl get services -l run=first-deploy-whoami</span><br><span class="line">NAME                        TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">first-deploy-whoami-svc-1   LoadBalancer   10.103.234.1   &lt;pending&gt;     8080:30095/TCP   19h</span><br><span class="line">first-deploy-whoami-svc-2   NodePort       10.102.32.78   &lt;none&gt;        80:31502/TCP     19h</span><br><span class="line">first-deploy-whoami-svc-3   ClusterIP      10.101.43.23   &lt;none&gt;        8080/TCP         19h</span><br></pre></td></tr></table></figure><p>我们把pod放到 <code>POD_NAME</code> 变量中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POD_NAME=$(kubectl get pods -o go-template --template <span class="string">'&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;"\n"&#125;&#125;&#123;&#123;end&#125;&#125;'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$POD_NAME</span></span><br></pre></td></tr></table></figure><p>我们可以先看下这个Pod的Labels：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod <span class="variable">$POD_NAME</span></span><br></pre></td></tr></table></figure><p>其中有如下输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Labels:             <span class="attribute">pod-template-hash</span>=68dd7db55</span><br><span class="line">                    <span class="attribute">run</span>=first-deploy-whoami</span><br></pre></td></tr></table></figure><p>现在我们给这个Pod增加一个应用版本号 <code>app_version</code> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label pod <span class="variable">$POD_NAME</span> app_version=v1</span><br></pre></td></tr></table></figure><p>再来看一下Pod的Labels，会看到如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  clark kubectl describe pod <span class="variable">$POD_NAME</span></span><br><span class="line">...</span><br><span class="line">Labels:             app_version=v1</span><br><span class="line">                    pod-template-hash=68dd7db55</span><br><span class="line">                    run=first-deploy-whoami</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们可以用新的Labels来获取Pods:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  clark kubectl <span class="keyword">get</span> pods -l app_version=v1</span><br><span class="line">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">first-deploy-whoami<span class="number">-68</span>dd7db55-qtfdq   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">37</span>m</span><br></pre></td></tr></table></figure><p><a name="kJiXX"></a></p><h3 id="删除-Service"><a href="#删除-Service" class="headerlink" title="删除 Service"></a>删除 Service</h3><p>我们之前创建了几个Service，我们当然可以沿用笨方法去删除，但有了Labels后，我们就可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete service -l run=first-deploy-whoami</span><br></pre></td></tr></table></figure><p>在我们的例子中，你会看到如下输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service <span class="string">"first-deploy-whoami-svc-1"</span> deleted</span><br><span class="line">service <span class="string">"first-deploy-whoami-svc-2"</span> deleted</span><br><span class="line">service <span class="string">"first-deploy-whoami-svc-3"</span> deleted</span><br></pre></td></tr></table></figure><p>通过下面的命令应该发现Service不见了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></table></figure><p>删除Service之后，讲道理，我们之前的访问方式应该是不可用了，我们可以使用之前的命令校验下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://192.168.99.101:30095/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube.exe service list</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run <span class="built_in">test</span>-service-pod -it --rm --restart=Never --image=busybox --port=80 --generator=run-pod/v1 -- wget -q -O - http://first-deploy-whoami-svc-1:8080</span><br></pre></td></tr></table></figure><p>但是，Pod中访问自己，应该还是一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  clark kubectl <span class="built_in">exec</span> -it <span class="variable">$POD_NAME</span> -- wget -q -O - http://localhost</span><br><span class="line">Hostname: first-deploy-whoami-68dd7db55-qtfdq</span><br><span class="line">IP: 127.0.0.1</span><br><span class="line">IP: 172.17.0.7</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Wget</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《浅入浅出k8s实战-k8s初体验篇的第五篇 》&lt;/p&gt;
&lt;p&gt;此文为提取大纲，按照互动教程进行分享教学用。另补充一些知识点，和关联操作。&lt;/p&gt;
&lt;p&gt;原文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中：&lt;a href=&quot;https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/expose-intro/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/expose-intro/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;英：&lt;a href=&quot;https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;互动：&lt;a href=&quot;https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-interactive/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-interactive/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name=&quot;nysyV&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;课程说明&quot;&gt;&lt;a href=&quot;#课程说明&quot; class=&quot;headerlink&quot; title=&quot;课程说明&quot;&gt;&lt;/a&gt;课程说明&lt;/h2&gt;&lt;p&gt;&lt;a name=&quot;g0oq9&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;了解 Kubernetes Service（服务）&lt;/li&gt;
&lt;li&gt;了解 labels 和 LabelSelector 对象如何与 Service 关联&lt;/li&gt;
&lt;li&gt;通过 Service 将应用暴露到集群外部&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="容器,浅入浅出k8s实战" scheme="https://www.ikhan.top/categories/%E5%AE%B9%E5%99%A8-%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAk8s%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="k8s" scheme="https://www.ikhan.top/tags/k8s/"/>
    
      <category term="kubernetes" scheme="https://www.ikhan.top/tags/kubernetes/"/>
    
      <category term="浅入浅出k8s实战" scheme="https://www.ikhan.top/tags/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAk8s%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes Pod 的生命周期</title>
    <link href="https://www.ikhan.top/posts/k8s-concepts-pod-lifecyle.html"/>
    <id>https://www.ikhan.top/posts/k8s-concepts-pod-lifecyle.html</id>
    <published>2019-05-25T11:39:35.000Z</published>
    <updated>2019-05-26T03:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" rel="external nofollow noopener noreferrer" target="_blank">https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/</a></p><p><a name="zTJxZ"></a></p><h2 id="Pod-phase"><a href="#Pod-phase" class="headerlink" title="Pod phase"></a>Pod phase</h2><p>Pod 的 <code>status</code> 字段是一个 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#podstatus-v1-core" rel="external nofollow noopener noreferrer" target="_blank">PodStatus</a> 对象，这个对象有个 <code>phase</code> 字段。<br>Pod的阶段(phase)是对Pod在其生命周期中所处位置的简单的宏观的概述。这个阶段（phase）字段不是为了全面归纳容器或 Pod的状态，也不打算成为全面的状态机。</p><p>Pod 阶段的数量和含义是严格指定的。除了本文档列举的内容外，不应该再假设Pod会有其他的 <code>phase</code> 值。</p><p>下面是所有 <code>phase</code>的可能值:</p><a id="more"></a><table><thead><tr><th align="left">Value</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code>Pending</code></td><td align="left">The Pod has been accepted by the Kubernetes system, but one or more of the Container images has not been created. This includes time before being scheduled as well as time spent downloading images over the network, which could take a while.<br>Pod 已经被Kubernetes 系统接受，但是有一个或多个 Container 镜像还没被创建。这包含Pod被调度前和调度后通过网络下载镜像的时间，根据情况可能需要等一会。</td></tr><tr><td align="left"><code>Running</code></td><td align="left">The Pod has been bound to a node, and all of the Containers have been created. At least one Container is still running, or is in the process of starting or restarting.<br>Pod 已经被绑定到一个节点，而且所有的 Containers 已经被创建。至少有一个 Container 是正在运行的，或正处于启动中或重启中的状态。（也就是只要没都挂掉退出，没结束执行）</td></tr><tr><td align="left"><code>Succeeded</code></td><td align="left">All Containers in the Pod have terminated in success, and will not be restarted.<br>Pod 中所有的容器都成功的退出了（执行Job结束），而且不会被重启）。</td></tr><tr><td align="left"><code>Failed</code></td><td align="left">All Containers in the Pod have terminated, and at least one Container has terminated in failure. That is, the Container either exited with non-zero status or was terminated by the system.<br>Pod 中所有的 Containers都结束了，但不是所有的都成功，至少有一个失败了。也就是以非零的返回码退出或被系统终止。</td></tr><tr><td align="left"><code>Unknown</code></td><td align="left">For some reason the state of the Pod could not be obtained, typically due to an error in communicating with the host of the Pod.<br>由于某种原因无法取得 Pod 的状态，通常是由于Pod所在的宿主机（和master之间）的通信失败导致。（kubelet 无法正确上报状态）</td></tr></tbody></table><p><a name="pod-conditions"></a></p><h2 id="Pod-conditions"><a href="#Pod-conditions" class="headerlink" title="Pod conditions"></a>Pod conditions</h2><p>A Pod has a PodStatus, which has an array of <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#podcondition-v1-core" rel="external nofollow noopener noreferrer" target="_blank">PodConditions</a> through which the Pod has or has not passed. Each element of the PodCondition array has six possible fields:</p><ul><li><p>The <code>lastProbeTime</code> field provides a timestamp for when the Pod condition was last probed.<br></p></li><li><p>The <code>lastTransitionTime</code> field provides a timestamp for when the Pod last transitioned from one status to another.<br></p></li><li><p>The <code>message</code> field is a human-readable message indicating details about the transition.<br></p></li><li><p>The <code>reason</code> field is a unique, one-word, CamelCase reason for the condition’s last transition.<br></p></li><li><p>The <code>status</code> field is a string, with possible values “<code>True</code>”, “<code>False</code>”, and “<code>Unknown</code>”.<br></p></li><li><p>The<code>type</code>field is a string with the following possible values:</p><ul><li><code>PodScheduled</code>: the Pod has been scheduled to a node;</li><li><code>Ready</code>: the Pod is able to serve requests and should be added to the load balancing pools of all matching Services;</li><li><code>Initialized</code>: all <a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers" rel="external nofollow noopener noreferrer" target="_blank">init containers</a> have started successfully;</li><li><code>Unschedulable</code>: the scheduler cannot schedule the Pod right now, for example due to lack of resources or other constraints;</li><li><code>ContainersReady</code>: all containers in the Pod are ready.<br><a name="container-probes"></a><h2 id="Container-probes"><a href="#Container-probes" class="headerlink" title="Container probes"></a>Container probes</h2>A <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#probe-v1-core" rel="external nofollow noopener noreferrer" target="_blank">Probe</a> is a diagnostic performed periodically by the <a href="https://kubernetes.io/docs/admin/kubelet/" rel="external nofollow noopener noreferrer" target="_blank">kubelet</a> on a Container. To perform a diagnostic, the kubelet calls a<a href="https://godoc.org/k8s.io/kubernetes/pkg/api/v1#Handler" rel="external nofollow noopener noreferrer" target="_blank">Handler</a> implemented by the Container. There are three types of handlers:</li></ul></li><li><p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#execaction-v1-core" rel="external nofollow noopener noreferrer" target="_blank">ExecAction</a>: Executes a specified command inside the Container. The diagnostic is considered successful if the command exits with a status code of 0.<br></p></li><li><p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#tcpsocketaction-v1-core" rel="external nofollow noopener noreferrer" target="_blank">TCPSocketAction</a>: Performs a TCP check against the Container’s IP address on a specified port. The diagnostic is considered successful if the port is open.<br></p></li><li><p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#httpgetaction-v1-core" rel="external nofollow noopener noreferrer" target="_blank">HTTPGetAction</a>: Performs an HTTP Get request against the Container’s IP address on a specified port and path. The diagnostic is considered successful if the response has a status code greater than or equal to 200 and less than 400.<br></p></li></ul><p>Each probe has one of three results:</p><ul><li>Success: The Container passed the diagnostic.</li><li>Failure: The Container failed the diagnostic.</li><li>Unknown: The diagnostic failed, so no action should be taken.</li></ul><p>The kubelet can optionally perform and react to two kinds of probes on running Containers:</p><ul><li><p><code>livenessProbe</code>: Indicates whether the Container is running. If the liveness probe fails, the kubelet kills the Container, and the Container is subjected to its <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy" rel="external nofollow noopener noreferrer" target="_blank">restart policy</a>. If a Container does not provide a liveness probe, the default state is <code>Success</code>.<br></p></li><li><p><code>readinessProbe</code>: Indicates whether the Container is ready to service requests. If the readiness probe fails, the endpoints controller removes the Pod’s IP address from the endpoints of all Services that match the Pod. The default state of readiness before the initial delay is <code>Failure</code>. If a Container does not provide a readiness probe, the default state is <code>Success</code>.<br><br><a name="when-should-you-use-liveness-or-readiness-probes"></a></p><h3 id="When-should-you-use-liveness-or-readiness-probes"><a href="#When-should-you-use-liveness-or-readiness-probes" class="headerlink" title="When should you use liveness or readiness probes?"></a>When should you use liveness or readiness probes?</h3><p>If the process in your Container is able to crash on its own whenever it encounters an issue or becomes unhealthy, you do not necessarily need a liveness probe; the kubelet will automatically perform the correct action in accordance with the Pod’s <code>restartPolicy</code>.<br>If you’d like your Container to be killed and restarted if a probe fails, then specify a liveness probe, and specify a <code>restartPolicy</code> of Always or OnFailure.<br>If you’d like to start sending traffic to a Pod only when a probe succeeds, specify a readiness probe. In this case, the readiness probe might be the same as the liveness probe, but the existence of the readiness probe in the spec means that the Pod will start without receiving any traffic and only start receiving traffic after the probe starts succeeding. If your Container needs to work on loading large data, configuration files, or migrations during startup, specify a readiness probe.<br>If you want your Container to be able to take itself down for maintenance, you can specify a readiness probe that checks an endpoint specific to readiness that is different from the liveness probe.<br>Note that if you just want to be able to drain requests when the Pod is deleted, you do not necessarily need a readiness probe; on deletion, the Pod automatically puts itself into an unready state regardless of whether the readiness probe exists. The Pod remains in the unready state while it waits for the Containers in the Pod to stop.<br>For more information about how to set up a liveness or readiness probe, see <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" rel="external nofollow noopener noreferrer" target="_blank">Configure Liveness and Readiness Probes</a>.<br><a name="pod-and-container-status"></a></p><h2 id="Pod-and-Container-status"><a href="#Pod-and-Container-status" class="headerlink" title="Pod and Container status"></a>Pod and Container status</h2><p>For detailed information about Pod Container status, see <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#podstatus-v1-core" rel="external nofollow noopener noreferrer" target="_blank">PodStatus</a> and <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#containerstatus-v1-core" rel="external nofollow noopener noreferrer" target="_blank">ContainerStatus</a>. Note that the information reported as Pod status depends on the current <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#containerstatus-v1-core" rel="external nofollow noopener noreferrer" target="_blank">ContainerState</a>.<br><a name="container-states"></a></p><h2 id="Container-States"><a href="#Container-States" class="headerlink" title="Container States"></a>Container States</h2><p>Once Pod is assigned to a node by scheduler, kubelet starts creating containers using container runtime.There are three possible states of containers: Waiting, Running and Terminated. To check state of container, you can use <code>kubectl describe pod [POD_NAME]</code>. State is displayed for each container within that Pod.</p></li><li><p><code>Waiting</code>: Default state of container. If container is not in either Running or Terminated state, it is in Waiting state. A container in Waiting state still runs its required operations, like pulling images, applying Secrets, etc. Along with this state, a message and reason about the state are displayed to provide more information.</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="symbol">  State:</span>          Waiting</span><br><span class="line"><span class="symbol">   Reason:</span>       ErrImagePull</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li><li><p><code>Running</code>: Indicates that the container is executing without issues. Once a container enters into Running, <code>postStart</code> hook (if any) is executed. This state also displays the time when the container entered Running state.<br></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      State:          Running</span><br><span class="line">       Started:      Wed, <span class="number">30</span> Jan <span class="number">2019</span> <span class="number">16</span>:<span class="number">46</span>:<span class="number">38</span> +<span class="number">0530</span></span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></li><li><p><code>Terminated</code>: Indicates that the container completed its execution and has stopped running. A container enters into this when it has successfully completed execution or when it has failed for some reason. Regardless, a reason and exit code is displayed, as well as the container’s start and finish time. Before a container enters into Terminated, <code>preStop</code> hook (if any) is executed.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      State:          Terminated</span><br><span class="line">        Reason:       Completed</span><br><span class="line">        Exit Code:    <span class="number">0</span></span><br><span class="line">        Started:      Wed, <span class="number">30</span> Jan <span class="number">2019</span> <span class="number">11</span>:<span class="number">45</span>:<span class="number">26</span> +<span class="number">0530</span></span><br><span class="line">        Finished:     Wed, <span class="number">30</span> Jan <span class="number">2019</span> <span class="number">11</span>:<span class="number">45</span>:<span class="number">26</span> +<span class="number">0530</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ul><p><a name="pod-readiness-gate"></a></p><h2 id="Pod-readiness-gate"><a href="#Pod-readiness-gate" class="headerlink" title="Pod readiness gate"></a>Pod readiness gate</h2><p><strong>FEATURE STATE:</strong> <code>Kubernetes v1.14</code> <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#" rel="external nofollow noopener noreferrer" target="_blank">stable</a><br>In order to add extensibility to Pod readiness by enabling the injection of extra feedbacks or signals into <code>PodStatus</code>, Kubernetes 1.11 introduced a feature named <a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/0007-pod-ready%2B%2B.md" rel="external nofollow noopener noreferrer" target="_blank">Pod ready++</a>. You can use the new field <code>ReadinessGate</code> in the <code>PodSpec</code> to specify additional conditions to be evaluated for Pod readiness. If Kubernetes cannot find such a condition in the <code>status.conditions</code> field of a Pod, the status of the condition is default to “<code>False</code>”. Below is an example:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">readinessGates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">conditionType:</span> <span class="string">"www.example.com/feature-1"</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Ready</span>  <span class="comment"># this is a builtin PodCondition</span></span><br><span class="line">      <span class="attr">status:</span> <span class="string">"False"</span></span><br><span class="line">      <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">lastTransitionTime:</span> <span class="number">2018</span><span class="number">-01</span><span class="string">-01T00:00:00Z</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">"www.example.com/feature-1"</span>   <span class="comment"># an extra PodCondition</span></span><br><span class="line">      <span class="attr">status:</span> <span class="string">"False"</span></span><br><span class="line">      <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">lastTransitionTime:</span> <span class="number">2018</span><span class="number">-01</span><span class="string">-01T00:00:00Z</span></span><br><span class="line">  <span class="attr">containerStatuses:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerID:</span> <span class="string">docker://abcd...</span></span><br><span class="line">      <span class="attr">ready:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>The new Pod conditions must comply with Kubernetes <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set" rel="external nofollow noopener noreferrer" target="_blank">label key format</a>. Since the <code>kubectl patch</code> command still doesn’t support patching object status, the new Pod conditions have to be injected through the <code>PATCH</code> action using one of the <a href="https://kubernetes.io/docs/reference/using-api/client-libraries/" rel="external nofollow noopener noreferrer" target="_blank">KubeClient libraries</a>.<br>With the introduction of new Pod conditions, a Pod is evaluated to be ready <strong>only</strong> when both the following statements are true:</p><ul><li>All containers in the Pod are ready.</li><li>All conditions specified in <code>ReadinessGates</code> are “<code>True</code>”.</li></ul><p>To facilitate this change to Pod readiness evaluation, a new Pod condition <code>ContainersReady</code> is introduced to capture the old Pod <code>Ready</code> condition.<br>In K8s 1.11, as an alpha feature, the “Pod Ready++” feature has to be explicitly enabled by setting the <code>PodReadinessGates</code><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/" rel="external nofollow noopener noreferrer" target="_blank">feature gate</a> to true.<br>In K8s 1.12, the feature is enabled by default.<br><a name="restart-policy"></a></p><h2 id="Restart-policy"><a href="#Restart-policy" class="headerlink" title="Restart policy"></a>Restart policy</h2><p>A PodSpec has a <code>restartPolicy</code> field with possible values Always, OnFailure, and Never. The default value is Always. <code>restartPolicy</code> applies to all Containers in the Pod. <code>restartPolicy</code> only refers to restarts of the Containers by the kubelet on the same node. Exited Containers that are restarted by the kubelet are restarted with an exponential back-off delay (10s, 20s, 40s …) capped at five minutes, and is reset after ten minutes of successful execution. As discussed in the <a href="https://kubernetes.io/docs/user-guide/pods/#durability-of-pods-or-lack-thereof" rel="external nofollow noopener noreferrer" target="_blank">Pods document</a>, once bound to a node, a Pod will never be rebound to another node.<br><a name="pod-lifetime"></a></p><h2 id="Pod-lifetime"><a href="#Pod-lifetime" class="headerlink" title="Pod lifetime"></a>Pod lifetime</h2><p>In general, Pods do not disappear until someone destroys them. This might be a human or a controller. The only exception to this rule is that Pods with a <code>phase</code> of Succeeded or Failed for more than some duration (determined by <code>terminated-pod-gc-threshold</code> in the master) will expire and be automatically destroyed.<br>Three types of controllers are available:</p><ul><li>Use a <a href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/" rel="external nofollow noopener noreferrer" target="_blank">Job</a> for Pods that are expected to terminate, for example, batch computations. Jobs are appropriate only for Pods with <code>restartPolicy</code> equal to OnFailure or Never.<br></li><li>Use a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" rel="external nofollow noopener noreferrer" target="_blank">ReplicationController</a>, <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" rel="external nofollow noopener noreferrer" target="_blank">ReplicaSet</a>, or <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="external nofollow noopener noreferrer" target="_blank">Deployment</a> for Pods that are not expected to terminate, for example, web servers. ReplicationControllers are appropriate only for Pods with a <code>restartPolicy</code> of Always.<br></li><li>Use a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" rel="external nofollow noopener noreferrer" target="_blank">DaemonSet</a> for Pods that need to run one per machine, because they provide a machine-specific system service.<br></li></ul><p>All three types of controllers contain a PodTemplate. It is recommended to create the appropriate controller and let it create Pods, rather than directly create Pods yourself. That is because Pods alone are not resilient to machine failures, but controllers are.<br>If a node dies or is disconnected from the rest of the cluster, Kubernetes applies a policy for setting the <code>phase</code> of all Pods on the lost node to Failed.<br><a name="examples"></a></p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p><a name="advanced-liveness-probe-example"></a></p><h3 id="Advanced-liveness-probe-example"><a href="#Advanced-liveness-probe-example" class="headerlink" title="Advanced liveness probe example"></a>Advanced liveness probe example</h3><p>Liveness probes are executed by the kubelet, so all requests are made in the kubelet network namespace.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">test:</span> <span class="string">liveness</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-http</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/server</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s.gcr.io/liveness</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="comment"># when "host" is not defined, "PodIP" will be used</span></span><br><span class="line">        <span class="comment"># host: my-host</span></span><br><span class="line">        <span class="comment"># when "scheme" is not defined, "HTTP" scheme will be used. Only "HTTP" and "HTTPS" are allowed</span></span><br><span class="line">        <span class="comment"># scheme: HTTPS</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/healthz</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">httpHeaders:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">X-Custom-Header</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">Awesome</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">liveness</span></span><br></pre></td></tr></table></figure><p><a name="example-states"></a></p><h3 id="Example-states"><a href="#Example-states" class="headerlink" title="Example states"></a>Example states</h3><ul><li><p>Pod is running and has one Container. Container exits with success.</p><ul><li>Log completion event.</li><li>If<code>restartPolicy</code>is:<ul><li>Always: Restart Container; Pod <code>phase</code> stays Running.</li><li>OnFailure: Pod <code>phase</code> becomes Succeeded.</li><li>Never: Pod <code>phase</code> becomes Succeeded.</li></ul></li></ul></li><li><p>Pod is running and has one Container. Container exits with failure.</p><ul><li>Log failure event.</li><li>If<code>restartPolicy</code>is:<ul><li>Always: Restart Container; Pod <code>phase</code> stays Running.</li><li>OnFailure: Restart Container; Pod <code>phase</code> stays Running.</li><li>Never: Pod <code>phase</code> becomes Failed.</li></ul></li></ul></li><li><p>Pod is running and has two Containers. Container 1 exits with failure.</p><ul><li>Log failure event.</li><li>If<code>restartPolicy</code>is:<ul><li>Always: Restart Container; Pod <code>phase</code> stays Running.</li><li>OnFailure: Restart Container; Pod <code>phase</code> stays Running.</li><li>Never: Do not restart Container; Pod <code>phase</code> stays Running.</li></ul></li><li>If Container 1 is not running, and Container 2 exits:<ul><li>Log failure event.</li><li>If<code>restartPolicy</code>is:<ul><li>Always: Restart Container; Pod <code>phase</code> stays Running.</li><li>OnFailure: Restart Container; Pod <code>phase</code> stays Running.</li><li>Never: Pod <code>phase</code> becomes Failed.</li></ul></li></ul></li></ul></li><li><p>Pod is running and has one Container. Container runs out of memory.</p><ul><li>Container terminates in failure.</li><li>Log OOM event.</li><li>If<code>restartPolicy</code>is:<ul><li>Always: Restart Container; Pod <code>phase</code> stays Running.</li><li>OnFailure: Restart Container; Pod <code>phase</code> stays Running.</li><li>Never: Log failure event; Pod <code>phase</code> becomes Failed.</li></ul></li></ul></li><li><p>Pod is running, and a disk dies.</p><ul><li>Kill all Containers.</li><li>Log appropriate event.</li><li>Pod <code>phase</code> becomes Failed.</li><li>If running under a controller, Pod is recreated elsewhere.</li></ul></li><li><p>Pod is running, and its node is segmented out.</p><ul><li>Node controller waits for timeout.</li><li>Node controller sets Pod <code>phase</code> to Failed.</li><li>If running under a controller, Pod is recreated elsewhere.<br><a name="what-s-next"></a><h2 id="What’s-next"><a href="#What’s-next" class="headerlink" title="What’s next"></a>What’s next</h2></li></ul></li><li><p>Get hands-on experience <a href="https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/" rel="external nofollow noopener noreferrer" target="_blank">attaching handlers to Container lifecycle events</a>.<br></p></li><li><p>Get hands-on experience <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" rel="external nofollow noopener noreferrer" target="_blank">configuring liveness and readiness probes</a>.<br></p></li><li><p>Learn more about <a href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/" rel="external nofollow noopener noreferrer" target="_blank">Container lifecycle hooks</a>.<br></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;zTJxZ&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Pod-phase&quot;&gt;&lt;a href=&quot;#Pod-phase&quot; class=&quot;headerlink&quot; title=&quot;Pod phase&quot;&gt;&lt;/a&gt;Pod phase&lt;/h2&gt;&lt;p&gt;Pod 的 &lt;code&gt;status&lt;/code&gt; 字段是一个 &lt;a href=&quot;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#podstatus-v1-core&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;PodStatus&lt;/a&gt; 对象，这个对象有个 &lt;code&gt;phase&lt;/code&gt; 字段。&lt;br&gt;Pod的阶段(phase)是对Pod在其生命周期中所处位置的简单的宏观的概述。这个阶段（phase）字段不是为了全面归纳容器或 Pod的状态，也不打算成为全面的状态机。&lt;/p&gt;
&lt;p&gt;Pod 阶段的数量和含义是严格指定的。除了本文档列举的内容外，不应该再假设Pod会有其他的 &lt;code&gt;phase&lt;/code&gt; 值。&lt;/p&gt;
&lt;p&gt;下面是所有 &lt;code&gt;phase&lt;/code&gt;的可能值:&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://www.ikhan.top/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="k8s" scheme="https://www.ikhan.top/tags/k8s/"/>
    
      <category term="kubernetes" scheme="https://www.ikhan.top/tags/kubernetes/"/>
    
      <category term="spinnaker" scheme="https://www.ikhan.top/tags/spinnaker/"/>
    
  </entry>
  
  <entry>
    <title>K8S互动教程3-查看 Pod 和 Nodes</title>
    <link href="https://www.ikhan.top/posts/qrqc-basic-k8s-interactive-tutorial-3.html"/>
    <id>https://www.ikhan.top/posts/qrqc-basic-k8s-interactive-tutorial-3.html</id>
    <published>2019-05-23T09:33:01.000Z</published>
    <updated>2019-05-23T14:42:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《浅入浅出k8s实战-k8s初体验篇的第四篇 》</p><p>此文为提取大纲，按照互动教程进行分享教学用。另补充一些知识点，和关联操作。</p><p>原文：</p><ul><li>中：<a href="https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/explore-intro/" rel="external nofollow noopener noreferrer" target="_blank">https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/explore-intro/</a></li><li>英：<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/" rel="external nofollow noopener noreferrer" target="_blank">https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/</a></li><li>互动：<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-interactive/" rel="external nofollow noopener noreferrer" target="_blank">https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-interactive/</a><br><a name="mnyq9"></a><h1 id="课程说明"><a href="#课程说明" class="headerlink" title="课程说明"></a>课程说明</h1></li></ul><p><a name="g0oq9"></a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>了解 Kubernetes Pods</li><li>了解 Kubernetes Nodes</li><li>已部署应用的故障排查</li></ul><a id="more"></a><p><a name="b9NpW"></a></p><h3 id="操作内容"><a href="#操作内容" class="headerlink" title="操作内容"></a>操作内容</h3><ul><li><p>查看已部署的 Pod 和配置</p></li><li><p>查看应用日志</p></li><li><p>在容器中运行命令<br><a name="7emFS"></a></p><h3 id="Kubernetes-Pods"><a href="#Kubernetes-Pods" class="headerlink" title="Kubernetes Pods"></a>Kubernetes Pods</h3><p>我们在 <a href="https://www.ikhan.top/posts/qrqc-basic-k8s-interactive-tutorial-2.html#%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8">上一节</a> 中创建了 Deployment 的时候，Kubernetes 创建了一个 Pod 来托管我们的应用实例。Pod 是 Kubernetes 的资源抽象，代表了<strong>一个或多个应用容器（如 Docker 或 rkt ）以及用于这些容器的一些共享资源集合</strong>。这些共享资源包含：</p></li><li><p>共享存储，就是 Volumes</p></li><li><p>网络，会被分配唯一的集群IP地址</p></li><li><p>每个容器如何运行的信息，比如容器镜像版本或要被使用的特定端口</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/svg/328984/1558621084284-4f51166d-641d-4ba8-b2a1-23ef7b255c2c.svg#align=left&display=inline&height=308&originHeight=124&originWidth=300&status=done&width=746" alt></p><p>Pod 相当于是应用程序特定的“逻辑主机”的一个建模，可以包含相对紧耦合的不同的应用容器。所以可以认为Pod地位是和曾经的虚拟化世界中的虚拟主机对等，而容器和虚拟主机中的进程对等。比如，Pod 中包含两个容器，一个是 Web应用程序的容器，会接受用户请求和处理数据，并产生一些处理记录，如日志。另外一个容器就是对第一个容器产生的数据进行再次处理，但不是一个领域，如收集归档日志的 <code>fluentd</code>。这样两个容器就是紧密协作的，需要共享存储等上下文环境、统一调度。</p><p>Pod 是 Kubernetes 平台上的原子单元。当我们在 Kubernetes 上创建一个 Deployment 的时候，这个部署会创建包含容器的Pod（而不是由 Deployment 直接创建容器）。每一个Pod会绑定到它被调度的 Node 上，始终在那里，直到（根据重启策略）或被删除。在 Node 故障的情况下，相同的 Pod （新的）会被调度到集群中其他可用节点。</p><p><a name="mZdeD"></a></p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>Pod 总是运行在 Node 上的。<strong>Node 是 Kubernetes 集群中的工作机器，取决于集群情况，可以是虚拟机或物理机。</strong>所有的Node都是被 Master 管理。<strong>一个Node上可以运行多个Pods</strong>，Kubernetes master会自动在集群中的 Node 之间处理调度 Pod。Mater 的自动调度会考虑到每个节点的可用资源。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/svg/328984/1558621939089-9c6021a6-38eb-4910-948b-4e2978a0bec7.svg#align=left&display=inline&height=639&originHeight=150&originWidth=175&size=0&status=done&width=746" alt></p><p>每个 Kubernetes Node 上至少运行一下组件：</p><ul><li>Kubelet，负责 Kubernetes Master 和 Node 之间通信的进程。它管理着一个机器上运行的 Pods 和 containers。</li><li>容器运行时（container runtime，如 Docker，rkt）负责从镜像仓库拉取容器镜像，解包容器并运行应用。</li></ul><p>如果一些容器是紧耦合的并且需要共享类似磁盘这样的资源，那么这些容器应该被放到一个Pod 中一起被调度。<br><a name="8oD88"></a></p><h3 id="使用-kubectl-进行故障排查"><a href="#使用-kubectl-进行故障排查" class="headerlink" title="使用 kubectl 进行故障排查"></a>使用 kubectl 进行故障排查</h3><p>在<a href="https://www.ikhan.top/posts/qrqc-basic-k8s-interactive-tutorial-2.html#%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8">上一节</a> 我们使用了Kubectl 命令行接口。我们在本章节继续使用它来获取已部署的应用及其环境的信息。最常用的操作可以通过以下命令完成：</p><ul><li>*<em>kubectl get *</em>列出资源</li><li><strong>kubectl describe</strong> 展示资源的相信信息</li><li><strong>kubeclt logs</strong> 打印 Pod 中 container 的日志</li><li><strong>kubectl exec</strong> 在 Pod 的 container 中执行命令</li></ul><p>我们可以用这些命令来查看我们是在啥时候部署的应用，它们当前的状态是咋样的，它们在哪里运行以及它们的配置是个啥。</p><p>现在，我们已经进一步的了解集群的组件和命令行，下面进入互动教程开始探索吧。</p><p><a name="1uvVA"></a></p><h2 id="互动教程"><a href="#互动教程" class="headerlink" title="互动教程"></a>互动教程</h2><p><a name="TiEuS"></a></p><h3 id="查看已部署的-Pod-和配置"><a href="#查看已部署的-Pod-和配置" class="headerlink" title="查看已部署的 Pod 和配置"></a>查看已部署的 Pod 和配置</h3><p>先按照<a href="https://www.ikhan.top/posts/qrqc-basic-k8s-interactive-tutorial-2.html#%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8">上一节</a>将我们的应用启动起来。</p><p>之后运行 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>如果还没启动好，等一等在运行这个命令。</p><p>我们可以通过 <code>describe</code> 来看 Pod 的详细信息，包括 Pod 运行的是哪些镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pods</span><br></pre></td></tr></table></figure><p>我们可以根据输出看到 Pod及其 container 的详细信息，包括 IP 地址，container 端口，Pod 生命周期的事件（events）记录。 <code>describe</code> 的输出包含了很多我们还没有覆盖到的内容，不过不用担心，教程结束后，你肯定会很熟悉。</p><blockquote><p>注意， <code>describe</code> 命令可用于 Kubernetes 的绝大多数资源类型，包括 Node，Pod，Deployment 等。其输出被设计为可读的，而不是脚本化的，所以，不妨经常用用看。</p></blockquote><p><a name="mi50p"></a></p><h3 id="查看应用日志"><a href="#查看应用日志" class="headerlink" title="查看应用日志"></a>查看应用日志</h3><p>和 Docker 一样。应用程序任何向标准输出（STDOUT）输出的内容都会成为 Pod 中对应 container 的日志。我们可以通过 <code>logs</code> 命令来查看日志。</p><p>首先，上一节一样，把 Pod 名称放到变量中（你也可以手动 copy）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POD_NAME=$(kubectl get pods -o go-template --template <span class="string">'&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;"\n"&#125;&#125;&#123;&#123;end&#125;&#125;'</span>)</span><br></pre></td></tr></table></figure><p>然后，我们查看这个 Pod 的日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs <span class="variable">$POD_NAME</span></span><br></pre></td></tr></table></figure><p>需要注意的是，我们此处之所以直接查看 Pod 的日志，而不是 container 是因为我们的 Pod 中只有一个 container。<br>其常用的格式是：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">kubectl</span> <span class="selector-tag">logs</span> <span class="selector-attr">[-f]</span> <span class="selector-attr">[-p]</span> (POD | TYPE/NAME) <span class="selector-attr">[-c CONTAINER]</span> <span class="selector-attr">[options]</span></span><br></pre></td></tr></table></figure><p>你也可以使用类似下面的命令查看日志：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">kubectl</span> logs <span class="variable">$POD_NAME</span> -c first-deploy-whoami</span><br></pre></td></tr></table></figure><p><a name="4Q9zp"></a></p><h2 id="在容器中运行命令"><a href="#在容器中运行命令" class="headerlink" title="在容器中运行命令"></a>在容器中运行命令</h2><p>同样，类似于 Docker，Pod 中的 container 启动后我们可以直接在容器中运行命令。使用的 <code>kubctl</code> 命令也是 <code>exec</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> <span class="variable">$POD_NAME</span> env</span><br></pre></td></tr></table></figure><p>上面这条命令可以直接将容器内的 env 信息返回。如 <code>logs</code> 一样，我们省略了 container 名称，你也可以用同样方式加上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> <span class="variable">$POD_NAME</span> env -c first-deploy-whoami</span><br></pre></td></tr></table></figure><p>让我们直接启动一个 session 看一看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it <span class="variable">$POD_NAME</span> sh</span><br></pre></td></tr></table></figure><p><code>-i</code> 和 <code>-t</code> 分别用于传递 stdin 到容器和让你的 stdin 成为容器的 TTY。</p><p>我们的容器用的基础镜像是 busybox，默认有 <code>sh</code> 和一些基础工具（curl 是没有的，用 wget 代替）。进入容器后你就可以“为所欲为”了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> &amp;&amp; ls -al</span><br></pre></td></tr></table></figure><p>我们可以尝试通过 localhost 访问一下我们启动的 Http 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -q -O - http://localhost</span><br></pre></td></tr></table></figure><p>应该可以返回类似如下的信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Hostname:</span> <span class="string">first-deploy-whoami-68dd7db55-bpr52</span></span><br><span class="line"><span class="attr">IP:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">IP:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/</span> <span class="string">HTTP/1.1</span></span><br><span class="line"><span class="attr">Host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">User-Agent:</span> <span class="string">Wget</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">close</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《浅入浅出k8s实战-k8s初体验篇的第四篇 》&lt;/p&gt;
&lt;p&gt;此文为提取大纲，按照互动教程进行分享教学用。另补充一些知识点，和关联操作。&lt;/p&gt;
&lt;p&gt;原文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中：&lt;a href=&quot;https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/explore-intro/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/explore-intro/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;英：&lt;a href=&quot;https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;互动：&lt;a href=&quot;https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-interactive/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-interactive/&lt;/a&gt;&lt;br&gt;&lt;a name=&quot;mnyq9&quot;&gt;&lt;/a&gt;&lt;h1 id=&quot;课程说明&quot;&gt;&lt;a href=&quot;#课程说明&quot; class=&quot;headerlink&quot; title=&quot;课程说明&quot;&gt;&lt;/a&gt;课程说明&lt;/h1&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name=&quot;g0oq9&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;了解 Kubernetes Pods&lt;/li&gt;
&lt;li&gt;了解 Kubernetes Nodes&lt;/li&gt;
&lt;li&gt;已部署应用的故障排查&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="容器,浅入浅出k8s实战" scheme="https://www.ikhan.top/categories/%E5%AE%B9%E5%99%A8-%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAk8s%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="k8s" scheme="https://www.ikhan.top/tags/k8s/"/>
    
      <category term="kubernetes" scheme="https://www.ikhan.top/tags/kubernetes/"/>
    
      <category term="浅入浅出k8s实战" scheme="https://www.ikhan.top/tags/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAk8s%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Kubectl 命令参考</title>
    <link href="https://www.ikhan.top/posts/overview-of-kubectl.html"/>
    <id>https://www.ikhan.top/posts/overview-of-kubectl.html</id>
    <published>2019-05-22T12:39:35.000Z</published>
    <updated>2019-05-23T06:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Kubectl 是和 kubernetes 集群交互的命令行工具。 <code>kubectl</code> 会使用 <code>$HOME/.kube/config</code> 文件作为默认配置（也就是 kubeconfig）。我们可以通过设置环境变量 <code>KUBECONFIG</code> 或命令行选项 <code>--kubeconfig</code> 来指定 kubeconfig。</p><p>本文概述kubectl语法，介绍命令操作，并提供常见的示例。有关每个命令的详细信息，包括所有支持的 falgs 和子命令，请参阅<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands" rel="external nofollow noopener noreferrer" target="_blank">kubectl参考文档</a> 。有关安装说明，请参阅<a href="https://www.ikhan.top/posts/minikube-intro-and-install.html#kubectl-%E5%AE%89%E8%A3%85">安装kubectl</a>。</p><a id="more"></a><p><a name="U5XGg"></a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>命令行使用可以总结为如下语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">kubectl</span> <span class="selector-attr">[command]</span> <span class="selector-attr">[TYPE]</span> <span class="selector-attr">[NAME]</span> <span class="selector-attr">[flags]</span></span><br></pre></td></tr></table></figure><p>解释如下：</p><ul><li><p><code>command</code> 指定对一个或多个资源的操作，如 <code>create</code> ，<code>get</code> ，<code>describe</code> ，<code>delete</code> 。</p></li><li><p><code>TYPE</code> 指明了要操作的<a href="#资源类型">资源类型</a>。资源类型不区分大小写，可以使用单数、复数、缩写形式（注意，缩写是严格的，不能单复数大小写）。比如，如下几条命令有相同的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod pod1</span><br><span class="line">kubectl get pods pod1</span><br><span class="line">kubectl get po pod1</span><br></pre></td></tr></table></figure></li><li><p><code>NAME</code> 指明资源名称。名称区分大小写，如果省略了资源名称，则展示此类所有资源的详情。如 <code>kubectl get pods</code> 。</p></li></ul><p>在对多个资源应用一个操作的时候，可以按照资源的类型和名称分别指定每个资源，或指定一个或多个文件：</p><ul><li>通过类型和名称：<ul><li>同一个类型分组： <code>TYPE1 name1 name2 name&lt;#&gt;</code> <br>如： <code>kubectl get pod example-pod1 example-pod2</code> </li><li>具有不同类型的多个资源: <code>TYPE1/name1 TYPE1/name2 TYPE2/name3 TYPE&lt;#&gt;/name&lt;#&gt;</code> <br>如： <code>kubectl get pod/example-pod1 replicationcontroller/example-rc1</code> </li></ul></li><li>通过一个或多个文件指定资源： <code>-f file1 -f file2 -f file&lt;#&gt;</code> <ul><li>文件使用YAML格式而不是JSON格式。因为YAML对用户更友好，尤其是配置文件<br>如： <code>kubectl get pod -f ./pod.yaml</code> <blockquote><p>注意：命令行指定的 flags 优先级最高，会覆盖默认值和对应的环境变量</p></blockquote></li></ul></li></ul><p>如果需要查看帮助，使用 <code>kubectl help</code> 命令。<br><a name="PJtBW"></a></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>下表包含所有 <code>kubectl</code> 操作的简短描述和通常的语法结构：（TODO: 官方表格命令过期，新命令未添加全，后续补充）</p><table><thead><tr><th align="left">Operation</th><th align="left">Syntax</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code>annotate</code></td><td align="left"><code>kubectl annotate (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td><td align="left">Add or update the annotations of one or more resources.<br>添加或更新一个或多个资源的 annotations。</td></tr><tr><td align="left"><code>api-versions</code></td><td align="left"><code>kubectl api-versions [flags]</code></td><td align="left">List the API versions that are available.<br>查看可用的 API 版本。</td></tr><tr><td align="left"><code>apply</code></td><td align="left"><code>kubectl apply -f FILENAME [flags]</code></td><td align="left">Apply a configuration change to a resource from a file or stdin.<br>通过文件或输入将配置变更应用到资源。</td></tr><tr><td align="left"><code>attach</code></td><td align="left"><code>kubectl attach POD -c CONTAINER [-i] [-t] [flags]</code></td><td align="left">Attach to a running container either to view the output stream or interact with the container (stdin).<br>attach 到运行中的容器，以查看容器输出或和容器交互。类似于 docker 的 attach 操作。</td></tr><tr><td align="left"><code>autoscale</code></td><td align="left"><code>kubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</code></td><td align="left">Automatically scale the set of pods that are managed by a replication controller.<br>对通过 replication controller 管理的 pods 进行自动的扩缩容。（使pods的负载在指定范围内。）</td></tr><tr><td align="left"><code>cluster-info</code></td><td align="left"><code>kubectl cluster-info [flags]</code></td><td align="left">Display endpoint information about the master and services in the cluster.<br>展示集群 master 和服务（非K8S资源的 Service类型）的端点信息。</td></tr><tr><td align="left"><code>config</code></td><td align="left"><code>kubectl config SUBCOMMAND [flags]</code></td><td align="left">Modifies kubeconfig files. See the individual subcommands for details.<br>修改 kubeconfig 配置内容。查看子命令获取更多信息。</td></tr><tr><td align="left"><code>create</code></td><td align="left"><code>kubectl create -f FILENAME [flags]</code></td><td align="left">Create one or more resources from a file or stdin.<br>通过文件或标准输入创建一个或多个资源。</td></tr><tr><td align="left"><code>delete</code></td><td align="left"><code>kubectl delete (-f FILENAME | TYPE [NAME | /NAME | -l label | --all]) [flags]</code></td><td align="left">Delete resources either from a file, stdin, or specifying label selectors, names, resource selectors, or resources.<br>删除资源。可以通过文件，标准输入或指定 label selectors，names，resource selectors,  resources 的方式。</td></tr><tr><td align="left"><code>describe</code></td><td align="left"><code>kubectl describe (-f FILENAME | TYPE [NAME_PREFIX | /NAME | -l label]) [flags]</code></td><td align="left">Display the detailed state of one or more resources.<br>展示一个或多个资源的详细信息。</td></tr><tr><td align="left"><code>diff</code></td><td align="left"><code>kubectl diff -f FILENAME [flags]</code></td><td align="left">Diff file or stdin against live configuration (<strong>BETA</strong>)<br>对比文件或标准输入与当前配置的区别。</td></tr><tr><td align="left"><code>edit</code></td><td align="left"><code>kubectl edit (-f FILENAME | TYPE NAME | TYPE/NAME) [flags]</code></td><td align="left">Edit and update the definition of one or more resources on the server by using the default editor.<br>通过默认的编辑器修改或更新集群中一个或多个资源</td></tr><tr><td align="left"><code>exec</code></td><td align="left"><code>kubectl exec POD [-c CONTAINER] [-i] [-t] [flags] [-- COMMAND [args...]]</code></td><td align="left">Execute a command against a container in a pod.<br>在 pod 的容器中执行一个命令。和 docker 的 exec 命令相似。</td></tr><tr><td align="left"><code>explain</code></td><td align="left"><code>kubectl explain [--recursive=false] [flags]</code></td><td align="left">Get documentation of various resources. For instance pods, nodes, services, etc.<br>获取各种资源类型的文档，比如，pods，nodes，services 等。</td></tr><tr><td align="left"><code>expose</code></td><td align="left"><code>kubectl expose (-f FILENAME | TYPE NAME | TYPE/NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type] [flags]</code></td><td align="left">Expose a replication controller, service, or pod as a new Kubernetes service.<br><br>将 replication controller（包括 deployment），service，pod暴露为一个新的 kubernetes service。</td></tr><tr><td align="left"><code>get</code></td><td align="left"><code>kubectl get (-f FILENAME | TYPE [NAME | /NAME | -l label]) [--watch] [--sort-by=FIELD] [[-o | --output]=OUTPUT_FORMAT] [flags]</code></td><td align="left">List one or more resources.<br>列出一个或多个资源。</td></tr><tr><td align="left"><code>label</code></td><td align="left"><code>kubectl label (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td><td align="left">Add or update the labels of one or more resources.<br>添加或更新一个或多个资源的 lables。</td></tr><tr><td align="left"><code>logs</code></td><td align="left"><code>kubectl logs POD [-c CONTAINER] [--follow] [flags]</code></td><td align="left">Print the logs for a container in a pod.<br>输出pod中某个container的日志。和 docker logs 类似。</td></tr><tr><td align="left"><code>patch</code></td><td align="left"><code>kubectl patch (-f FILENAME | TYPE NAME | TYPE/NAME) --patch PATCH [flags]</code></td><td align="left">Update one or more fields of a resource by using the strategic merge patch process.<br>更新资源的一个或多个字段。默认用策略性合并补丁（–type=’strategic’）方式。</td></tr><tr><td align="left"><code>port-forward</code></td><td align="left"><code>kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N] [flags]</code></td><td align="left">Forward one or more local ports to a pod.<br>转发一个或多个本地端口到pod。</td></tr><tr><td align="left"><code>proxy</code></td><td align="left"><code>kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]</code></td><td align="left">Run a proxy to the Kubernetes API server.<br>启动一个到 Kubernetes API server 的代理。</td></tr><tr><td align="left"><code>replace</code></td><td align="left"><code>kubectl replace -f FILENAME</code></td><td align="left">Replace a resource from a file or stdin.<br>从文件或标准输入替换一个资源。</td></tr><tr><td align="left"><code>rolling-update</code></td><td align="left"><code>kubectl rolling-update OLD_CONTROLLER_NAME ([NEW_CONTROLLER_NAME] --image=NEW_CONTAINER_IMAGE | -f NEW_CONTROLLER_SPEC) [flags]</code></td><td align="left">Perform a rolling update by gradually replacing the specified replication controller and its pods.<br>通过逐步替换 replication controller 和它的 pods 来实现一个滚动更新。(废弃了，用 rollout替代)。</td></tr><tr><td align="left"><code>run</code></td><td align="left"><code>kubectl run NAME --image=image [--env=&quot;key=value&quot;] [--port=port] [--replicas=replicas] [--dry-run=bool] [--overrides=inline-json] [flags]</code></td><td align="left">Run a specified image on the cluster.<br>在集群上运行特定的镜像。</td></tr><tr><td align="left"><code>scale</code></td><td align="left"><code>kubectl scale (-f FILENAME | TYPE NAME | TYPE/NAME) --replicas=COUNT [--resource-version=version] [--current-replicas=count] [flags]</code></td><td align="left">Update the size of the specified replication controller.<br>更新指定 replication controller 的副本数量。</td></tr><tr><td align="left"><code>stop</code></td><td align="left"><code>kubectl stop</code></td><td align="left">Deprecated: Instead, see <code>kubectl delete</code>.<br>废弃，使用 <code>kubectl delete</code>  替代。</td></tr><tr><td align="left"><code>version</code></td><td align="left"><code>kubectl version [--client] [flags]</code></td><td align="left">Display the Kubernetes version running on the client and server.<br>展示 Kubernetes 服务集群和本地客户端的版本。</td></tr></tbody></table><p>提示：关于命令操作的更多信息参见<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands" rel="external nofollow noopener noreferrer" target="_blank">kubectl参考文档</a> 。</p><p><a name="xVsVC"></a></p><h2 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h2><p>The following table includes a list of all the supported resource types and their abbreviated aliases.<br>(This output can be retrieved from <code>kubectl api-resources</code>, and is accurate as of Kubernetes 1.13.3.)</p><table><thead><tr><th align="left">Resource Name</th><th align="left">Short Names</th><th align="left">API Group</th><th align="left">Namespaced</th><th align="left">Resource Kind</th></tr></thead><tbody><tr><td align="left"><code>componentstatuses</code></td><td align="left"><code>cs</code></td><td align="left"></td><td align="left">false</td><td align="left">ComponentStatus</td></tr><tr><td align="left"><code>configmaps</code></td><td align="left"><code>cm</code></td><td align="left"></td><td align="left">true</td><td align="left">ConfigMap</td></tr><tr><td align="left"><code>endpoints</code></td><td align="left"><code>ep</code></td><td align="left"></td><td align="left">true</td><td align="left">Endpoints</td></tr><tr><td align="left"><code>limitranges</code></td><td align="left"><code>limits</code></td><td align="left"></td><td align="left">true</td><td align="left">LimitRange</td></tr><tr><td align="left"><code>namespaces</code></td><td align="left"><code>ns</code></td><td align="left"></td><td align="left">false</td><td align="left">Namespace</td></tr><tr><td align="left"><code>nodes</code></td><td align="left"><code>no</code></td><td align="left"></td><td align="left">false</td><td align="left">Node</td></tr><tr><td align="left"><code>persistentvolumeclaims</code></td><td align="left"><code>pvc</code></td><td align="left"></td><td align="left">true</td><td align="left">PersistentVolumeClaim</td></tr><tr><td align="left"><code>persistentvolumes</code></td><td align="left"><code>pv</code></td><td align="left"></td><td align="left">false</td><td align="left">PersistentVolume</td></tr><tr><td align="left"><code>pods</code></td><td align="left"><code>po</code></td><td align="left"></td><td align="left">true</td><td align="left">Pod</td></tr><tr><td align="left"><code>podtemplates</code></td><td align="left"></td><td align="left"></td><td align="left">true</td><td align="left">PodTemplate</td></tr><tr><td align="left"><code>replicationcontrollers</code></td><td align="left"><code>rc</code></td><td align="left"></td><td align="left">true</td><td align="left">ReplicationController</td></tr><tr><td align="left"><code>resourcequotas</code></td><td align="left"><code>quota</code></td><td align="left"></td><td align="left">true</td><td align="left">ResourceQuota</td></tr><tr><td align="left"><code>secrets</code></td><td align="left"></td><td align="left"></td><td align="left">true</td><td align="left">Secret</td></tr><tr><td align="left"><code>serviceaccounts</code></td><td align="left"><code>sa</code></td><td align="left"></td><td align="left">true</td><td align="left">ServiceAccount</td></tr><tr><td align="left"><code>services</code></td><td align="left"><code>svc</code></td><td align="left"></td><td align="left">true</td><td align="left">Service</td></tr><tr><td align="left"><code>mutatingwebhookconfigurations</code></td><td align="left"></td><td align="left">admissionregistration.k8s.io</td><td align="left">false</td><td align="left">MutatingWebhookConfiguration</td></tr><tr><td align="left"><code>validatingwebhookconfigurations</code></td><td align="left"></td><td align="left">admissionregistration.k8s.io</td><td align="left">false</td><td align="left">ValidatingWebhookConfiguration</td></tr><tr><td align="left"><code>customresourcedefinitions</code></td><td align="left"><code>crd</code>, <code>crds</code></td><td align="left">apiextensions.k8s.io</td><td align="left">false</td><td align="left">CustomResourceDefinition</td></tr><tr><td align="left"><code>apiservices</code></td><td align="left"></td><td align="left">apiregistration.k8s.io</td><td align="left">false</td><td align="left">APIService</td></tr><tr><td align="left"><code>controllerrevisions</code></td><td align="left"></td><td align="left">apps</td><td align="left">true</td><td align="left">ControllerRevision</td></tr><tr><td align="left"><code>daemonsets</code></td><td align="left"><code>ds</code></td><td align="left">apps</td><td align="left">true</td><td align="left">DaemonSet</td></tr><tr><td align="left"><code>deployments</code></td><td align="left"><code>deploy</code></td><td align="left">apps</td><td align="left">true</td><td align="left">Deployment</td></tr><tr><td align="left"><code>replicasets</code></td><td align="left"><code>rs</code></td><td align="left">apps</td><td align="left">true</td><td align="left">ReplicaSet</td></tr><tr><td align="left"><code>statefulsets</code></td><td align="left"><code>sts</code></td><td align="left">apps</td><td align="left">true</td><td align="left">StatefulSet</td></tr><tr><td align="left"><code>tokenreviews</code></td><td align="left"></td><td align="left">authentication.k8s.io</td><td align="left">false</td><td align="left">TokenReview</td></tr><tr><td align="left"><code>localsubjectaccessreviews</code></td><td align="left"></td><td align="left">authorization.k8s.io</td><td align="left">true</td><td align="left">LocalSubjectAccessReview</td></tr><tr><td align="left"><code>selfsubjectaccessreviews</code></td><td align="left"></td><td align="left">authorization.k8s.io</td><td align="left">false</td><td align="left">SelfSubjectAccessReview</td></tr><tr><td align="left"><code>selfsubjectrulesreviews</code></td><td align="left"></td><td align="left">authorization.k8s.io</td><td align="left">false</td><td align="left">SelfSubjectRulesReview</td></tr><tr><td align="left"><code>subjectaccessreviews</code></td><td align="left"></td><td align="left">authorization.k8s.io</td><td align="left">false</td><td align="left">SubjectAccessReview</td></tr><tr><td align="left"><code>horizontalpodautoscalers</code></td><td align="left"><code>hpa</code></td><td align="left">autoscaling</td><td align="left">true</td><td align="left">HorizontalPodAutoscaler</td></tr><tr><td align="left"><code>cronjobs</code></td><td align="left"><code>cj</code></td><td align="left">batch</td><td align="left">true</td><td align="left">CronJob</td></tr><tr><td align="left"><code>jobs</code></td><td align="left"></td><td align="left">batch</td><td align="left">true</td><td align="left">Job</td></tr><tr><td align="left"><code>certificatesigningrequests</code></td><td align="left"><code>csr</code></td><td align="left">certificates.k8s.io</td><td align="left">false</td><td align="left">CertificateSigningRequest</td></tr><tr><td align="left"><code>leases</code></td><td align="left"></td><td align="left">coordination.k8s.io</td><td align="left">true</td><td align="left">Lease</td></tr><tr><td align="left"><code>events</code></td><td align="left"><code>ev</code></td><td align="left">events.k8s.io</td><td align="left">true</td><td align="left">Event</td></tr><tr><td align="left"><code>ingresses</code></td><td align="left"><code>ing</code></td><td align="left">extensions</td><td align="left">true</td><td align="left">Ingress</td></tr><tr><td align="left"><code>networkpolicies</code></td><td align="left"><code>netpol</code></td><td align="left">networking.k8s.io</td><td align="left">true</td><td align="left">NetworkPolicy</td></tr><tr><td align="left"><code>poddisruptionbudgets</code></td><td align="left"><code>pdb</code></td><td align="left">policy</td><td align="left">true</td><td align="left">PodDisruptionBudget</td></tr><tr><td align="left"><code>podsecuritypolicies</code></td><td align="left"><code>psp</code></td><td align="left">policy</td><td align="left">false</td><td align="left">PodSecurityPolicy</td></tr><tr><td align="left"><code>clusterrolebindings</code></td><td align="left"></td><td align="left">rbac.authorization.k8s.io</td><td align="left">false</td><td align="left">ClusterRoleBinding</td></tr><tr><td align="left"><code>clusterroles</code></td><td align="left"></td><td align="left">rbac.authorization.k8s.io</td><td align="left">false</td><td align="left">ClusterRole</td></tr><tr><td align="left"><code>rolebindings</code></td><td align="left"></td><td align="left">rbac.authorization.k8s.io</td><td align="left">true</td><td align="left">RoleBinding</td></tr><tr><td align="left"><code>roles</code></td><td align="left"></td><td align="left">rbac.authorization.k8s.io</td><td align="left">true</td><td align="left">Role</td></tr><tr><td align="left"><code>priorityclasses</code></td><td align="left"><code>pc</code></td><td align="left">scheduling.k8s.io</td><td align="left">false</td><td align="left">PriorityClass</td></tr><tr><td align="left"><code>storageclasses</code></td><td align="left"><code>sc</code></td><td align="left">storage.k8s.io</td><td align="left">false</td><td align="left">StorageClass</td></tr><tr><td align="left"><code>volumeattachments</code></td><td align="left"></td><td align="left">storage.k8s.io</td><td align="left">false</td><td align="left">VolumeAttachment</td></tr></tbody></table><p><a name="SqhQo"></a></p><h2 id="输出选项"><a href="#输出选项" class="headerlink" title="输出选项"></a>输出选项</h2><p>Use the following sections for information about how you can format or sort the output of certain commands. For details about which commands support the various output options, see the <a href="https://kubernetes.io/docs/user-guide/kubectl/" rel="external nofollow noopener noreferrer" target="_blank">kubectl</a> reference documentation.<br><a name="formatting-output"></a></p><h3 id="Formatting-output"><a href="#Formatting-output" class="headerlink" title="Formatting output"></a>Formatting output</h3><p>The default output format for all <code>kubectl</code> commands is the human readable plain-text format. To output details to your terminal window in a specific format, you can add either the <code>-o</code>or <code>--output</code> flags to a supported <code>kubectl</code> command.<br><a name="syntax-1"></a></p><h4 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">kubectl</span> <span class="selector-attr">[command]</span> <span class="selector-attr">[TYPE]</span> <span class="selector-attr">[NAME]</span> <span class="selector-tag">-o</span> &lt;<span class="selector-tag">output_format</span>&gt;</span><br></pre></td></tr></table></figure><p>Depending on the <code>kubectl</code> operation, the following output formats are supported:</p><table><thead><tr><th align="left">Output format</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code>-o custom-columns=&lt;spec&gt;</code></td><td align="left">Print a table using a comma separated list of <a href="https://kubernetes.io/docs/reference/kubectl/overview/#custom-columns" rel="external nofollow noopener noreferrer" target="_blank">custom columns</a>.</td></tr><tr><td align="left"><code>-o custom-columns-file=&lt;filename&gt;</code></td><td align="left">Print a table using the <a href="https://kubernetes.io/docs/reference/kubectl/overview/#custom-columns" rel="external nofollow noopener noreferrer" target="_blank">custom columns</a> template in the <code>&lt;filename&gt;</code> file.</td></tr><tr><td align="left"><code>-o json</code></td><td align="left">Output a JSON formatted API object.</td></tr><tr><td align="left"><code>-o jsonpath=&lt;template&gt;</code></td><td align="left">Print the fields defined in a <a href="https://kubernetes.io/docs/reference/kubectl/jsonpath/" rel="external nofollow noopener noreferrer" target="_blank">jsonpath</a> expression.</td></tr><tr><td align="left"><code>-o jsonpath-file=&lt;filename&gt;</code></td><td align="left">Print the fields defined by the <a href="https://kubernetes.io/docs/reference/kubectl/jsonpath/" rel="external nofollow noopener noreferrer" target="_blank">jsonpath</a> expression in the <code>&lt;filename&gt;</code> file.</td></tr><tr><td align="left"><code>-o name</code></td><td align="left">Print only the resource name and nothing else.</td></tr><tr><td align="left"><code>-o wide</code></td><td align="left">Output in the plain-text format with any additional information. For pods, the node name is included.</td></tr><tr><td align="left"><code>-o yaml</code></td><td align="left">Output a YAML formatted API object.</td></tr></tbody></table><p><a name="example"></a></p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p>In this example, the following command outputs the details for a single pod as a YAML formatted object:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="builtin-name">get</span> pod web-pod-13je7 -o yaml</span><br></pre></td></tr></table></figure><p>Remember: See the <a href="https://kubernetes.io/docs/user-guide/kubectl/" rel="external nofollow noopener noreferrer" target="_blank">kubectl</a> reference documentation for details about which output format is supported by each command.<br><a name="custom-columns"></a></p><h4 id="Custom-columns"><a href="#Custom-columns" class="headerlink" title="Custom columns"></a>Custom columns</h4><p>To define custom columns and output only the details that you want into a table, you can use the <code>custom-columns</code> option. You can choose to define the custom columns inline or use a template file: <code>-o custom-columns=&lt;spec&gt;</code> or <code>-o custom-columns-file=&lt;filename&gt;</code>.<br><a name="examples"></a></p><h5 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h5><p>Inline:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> pods &lt;pod-<span class="type">name</span>&gt; -o custom-<span class="keyword">columns</span>=<span class="type">NAME</span>:.metadata.name,RSRC:.metadata.resourceVersion</span><br></pre></td></tr></table></figure><p>Template file:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">get</span> pods &lt;pod-<span class="type">name</span>&gt; -o custom-<span class="keyword">columns</span>-file=<span class="keyword">template</span>.txt</span><br></pre></td></tr></table></figure><p>where the <code>template.txt</code> file contains:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">NAME</span>          <span class="selector-tag">RSRC</span></span><br><span class="line"><span class="selector-tag">metadata</span><span class="selector-class">.name</span> <span class="selector-tag">metadata</span><span class="selector-class">.resourceVersion</span></span><br></pre></td></tr></table></figure><p>The result of running either command is:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME           RSRC</span><br><span class="line">submit-queue   <span class="number">610995</span></span><br></pre></td></tr></table></figure><p><a name="server-side-columns"></a></p><h4 id="Server-side-columns"><a href="#Server-side-columns" class="headerlink" title="Server-side columns"></a>Server-side columns</h4><p><code>kubectl</code> supports receiving specific column information from the server about objects. This means that for any given resource, the server will return columns and rows relevant to that resource, for the client to print. This allows for consistent human-readable output across clients used against the same cluster, by having the server encapsulate the details of printing.<br>This feature is enabled by default in <code>kubectl</code> 1.11 and higher. To disable it, add the <code>--server-print=false</code> flag to the <code>kubectl get</code> command.<br><a name="examples-1"></a></p><h5 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h5><p>To print information about the status of a pod, use a command like the following:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="builtin-name">get</span> pods &lt;pod-name&gt; <span class="attribute">--server-print</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>Output looks like this:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME       READY     STATUS              RESTARTS   AGE</span><br><span class="line">pod-name   <span class="number">1</span>/<span class="number">1</span>       Running             <span class="number">0</span>          <span class="number">1</span>m</span><br></pre></td></tr></table></figure><p><a name="sorting-list-objects"></a></p><h3 id="Sorting-list-objects"><a href="#Sorting-list-objects" class="headerlink" title="Sorting list objects"></a>Sorting list objects</h3><p>To output objects to a sorted list in your terminal window, you can add the <code>--sort-by</code> flag to a supported <code>kubectl</code> command. Sort your objects by specifying any numeric or string field with the <code>--sort-by</code> flag. To specify a field, use a <a href="https://kubernetes.io/docs/reference/kubectl/jsonpath/" rel="external nofollow noopener noreferrer" target="_blank">jsonpath</a> expression.<br><a name="syntax-2"></a></p><h4 id="Syntax-1"><a href="#Syntax-1" class="headerlink" title="Syntax"></a>Syntax</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="comment">[command]</span> <span class="comment">[TYPE]</span> <span class="comment">[NAME]</span> --sort-by=&lt;jsonpath_exp&gt;</span><br></pre></td></tr></table></figure><p><a name="example-1"></a></p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h5><p>To print a list of pods sorted by name, you run:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="builtin-name">get</span> pods <span class="attribute">--sort-by</span>=.metadata.name</span><br></pre></td></tr></table></figure><p><a name="3Lgze"></a></p><h2 id="示例：常用操作"><a href="#示例：常用操作" class="headerlink" title="示例：常用操作"></a>示例：常用操作</h2><p>Use the following set of examples to help you familiarize yourself with running the commonly used <code>kubectl</code> operations:<br><code>kubectl apply</code> - Apply or Update a resource from a file or stdin.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a service using the definition in example-service.yaml.</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">apply -f example-service.yaml</span></span><br><span class="line"><span class="comment"># Create a replication controller using the definition in example-controller.yaml.</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">apply -f example-controller.yaml</span></span><br><span class="line"><span class="comment"># Create the objects that are defined in any .yaml, .yml, or .json file within the &lt;directory&gt; directory.</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">apply -f &lt;directory&gt;</span></span><br></pre></td></tr></table></figure><p><code>kubectl get</code> - List one or more resources.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># List <span class="keyword">all</span> pods <span class="keyword">in</span> plain-<span class="type">text</span> output <span class="keyword">format</span>.</span><br><span class="line">kubectl <span class="keyword">get</span> pods</span><br><span class="line"># List <span class="keyword">all</span> pods <span class="keyword">in</span> plain-<span class="type">text</span> output <span class="keyword">format</span> <span class="keyword">and</span> <span class="keyword">include</span> additional information (such <span class="keyword">as</span> node <span class="type">name</span>).</span><br><span class="line">kubectl <span class="keyword">get</span> pods -o wide</span><br><span class="line"># List the <span class="keyword">replication</span> controller <span class="keyword">with</span> the specified <span class="type">name</span> <span class="keyword">in</span> plain-<span class="type">text</span> output <span class="keyword">format</span>. Tip: You can shorten <span class="keyword">and</span> replace the <span class="string">'replicationcontroller'</span> resource <span class="keyword">type</span> <span class="keyword">with</span> the <span class="keyword">alias</span> <span class="string">'rc'</span>.</span><br><span class="line">kubectl <span class="keyword">get</span> replicationcontroller &lt;rc-<span class="type">name</span>&gt;</span><br><span class="line"># List <span class="keyword">all</span> <span class="keyword">replication</span> controllers <span class="keyword">and</span> services together <span class="keyword">in</span> plain-<span class="type">text</span> output <span class="keyword">format</span>.</span><br><span class="line">kubectl <span class="keyword">get</span> rc,services</span><br><span class="line"># List <span class="keyword">all</span> daemon sets, including uninitialized ones, <span class="keyword">in</span> plain-<span class="type">text</span> output <span class="keyword">format</span>.</span><br><span class="line">kubectl <span class="keyword">get</span> ds <span class="comment">--include-uninitialized</span></span><br><span class="line"># List <span class="keyword">all</span> pods running <span class="keyword">on</span> node server01</span><br><span class="line">kubectl <span class="keyword">get</span> pods <span class="comment">--field-selector=spec.nodeName=server01</span></span><br></pre></td></tr></table></figure><p><code>kubectl describe</code> - Display detailed state of one or more resources, including the uninitialized ones by default.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Display the details of the node with name &lt;node-name&gt;.</span></span><br><span class="line">kubectl <span class="keyword">describe</span> nodes &lt;node-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment"># Display the details of the pod with name &lt;pod-name&gt;.</span></span><br><span class="line">kubectl <span class="keyword">describe</span> pods/&lt;pod-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment"># Display the details of all the pods that are managed by the replication controller named &lt;rc-name&gt;.</span></span><br><span class="line"><span class="comment"># Remember: Any pods that are created by the replication controller get prefixed with the name of the replication controller.</span></span><br><span class="line">kubectl <span class="keyword">describe</span> pods &lt;rc-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment"># Describe all pods, not including uninitialized ones</span></span><br><span class="line">kubectl <span class="keyword">describe</span> pods <span class="comment">--include-uninitialized=false</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Note:</strong> The <code>kubectl get</code> command is usually used for retrieving one or more resources of the same resource type. It features a rich set of flags that allows you to customize the output format using the <code>-o</code> or <code>--output</code> flag, for example. You can specify the <code>-w</code> or <code>--watch</code> flag to start watching updates to a particular object. The <code>kubectl describe</code> command is more focused on describing the many related aspects of a specified resource. It may invoke several API calls to the API server to build a view for the user. For example, the <code>kubectl describe node</code> command retrieves not only the information about the node, but also a summary of the pods running on it, the events generated for the node etc.</p></blockquote><p><code>kubectl delete</code> - Delete resources either from a file, stdin, or specifying label selectors, names, resource selectors, or resources.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">Delete</span> a pod <span class="keyword">using</span> the <span class="keyword">type</span> <span class="keyword">and</span> <span class="type">name</span> specified <span class="keyword">in</span> the pod.yaml file.</span><br><span class="line">kubectl <span class="keyword">delete</span> -f pod.yaml</span><br><span class="line"># <span class="keyword">Delete</span> <span class="keyword">all</span> the pods <span class="keyword">and</span> services that have the label <span class="type">name</span>=&lt;label-<span class="type">name</span>&gt;.</span><br><span class="line">kubectl <span class="keyword">delete</span> pods,services -l <span class="type">name</span>=&lt;label-<span class="type">name</span>&gt;</span><br><span class="line"># <span class="keyword">Delete</span> <span class="keyword">all</span> the pods <span class="keyword">and</span> services that have the label <span class="type">name</span>=&lt;label-<span class="type">name</span>&gt;, including uninitialized ones.</span><br><span class="line">kubectl <span class="keyword">delete</span> pods,services -l <span class="type">name</span>=&lt;label-<span class="type">name</span>&gt; <span class="comment">--include-uninitialized</span></span><br><span class="line"># <span class="keyword">Delete</span> <span class="keyword">all</span> pods, including uninitialized ones.</span><br><span class="line">kubectl <span class="keyword">delete</span> pods <span class="comment">--all</span></span><br></pre></td></tr></table></figure><p><code>kubectl exec</code> - Execute a command against a container in a pod.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">Get</span> output <span class="keyword">from</span> running <span class="string">'date'</span> <span class="keyword">from</span> pod &lt;pod-<span class="type">name</span>&gt;. <span class="keyword">By</span> <span class="keyword">default</span>, output <span class="keyword">is</span> <span class="keyword">from</span> the first container.</span><br><span class="line">kubectl exec &lt;pod-<span class="type">name</span>&gt; <span class="type">date</span></span><br><span class="line"># <span class="keyword">Get</span> output <span class="keyword">from</span> running <span class="string">'date'</span> <span class="keyword">in</span> container &lt;container-<span class="type">name</span>&gt; <span class="keyword">of</span> pod &lt;pod-<span class="type">name</span>&gt;.</span><br><span class="line">kubectl exec &lt;pod-<span class="type">name</span>&gt; -c &lt;container-<span class="type">name</span>&gt; <span class="type">date</span></span><br><span class="line"># <span class="keyword">Get</span> an interactive TTY <span class="keyword">and</span> run /bin/bash <span class="keyword">from</span> pod &lt;pod-<span class="type">name</span>&gt;. <span class="keyword">By</span> <span class="keyword">default</span>, output <span class="keyword">is</span> <span class="keyword">from</span> the first container.</span><br><span class="line">kubectl exec -ti &lt;pod-<span class="type">name</span>&gt; /bin/bash</span><br></pre></td></tr></table></figure><p><code>kubectl logs</code> - Print the logs for a container in a pod.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">Return</span> a <span class="keyword">snapshot</span> <span class="keyword">of</span> the logs <span class="keyword">from</span> pod &lt;pod-<span class="type">name</span>&gt;.</span><br><span class="line">kubectl logs &lt;pod-<span class="type">name</span>&gt;</span><br><span class="line"># <span class="keyword">Start</span> streaming the logs <span class="keyword">from</span> pod &lt;pod-<span class="type">name</span>&gt;. This <span class="keyword">is</span> <span class="keyword">similar</span> <span class="keyword">to</span> the <span class="string">'tail -f'</span> Linux command.</span><br><span class="line">kubectl logs -f &lt;pod-<span class="type">name</span>&gt;</span><br></pre></td></tr></table></figure><p><a name="s7IcX"></a></p><h2 id="示例：创建和使用-plugins"><a href="#示例：创建和使用-plugins" class="headerlink" title="示例：创建和使用 plugins"></a>示例：创建和使用 plugins</h2><p>Use the following set of examples to help you familiarize yourself with writing and using <code>kubectl</code> plugins:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create a simple plugin in any language and name the resulting executable file</span></span><br><span class="line"><span class="comment"># so that it begins with the prefix "kubectl-"</span></span><br><span class="line">cat ./kubectl-hello</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># this plugin prints the words "hello world"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello world"</span></span><br><span class="line"><span class="comment"># with our plugin written, let's make it executable</span></span><br><span class="line">sudo chmod +x ./kubectl-hello</span><br><span class="line"><span class="comment"># and move it to a location in our PATH</span></span><br><span class="line">sudo mv ./kubectl-hello /usr/<span class="built_in">local</span>/bin</span><br><span class="line"><span class="comment"># we have now created and "installed" a kubectl plugin.</span></span><br><span class="line"><span class="comment"># we can begin using our plugin by invoking it from kubectl as if it were a regular command</span></span><br><span class="line">kubectl hello</span><br></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hello world</span></span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># we can "uninstall" a plugin, by simply removing it from our PATH</span></span><br><span class="line">sudo rm <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>kubectl-hello</span><br></pre></td></tr></table></figure><p>In order to view all of the plugins that are available to <code>kubectl</code>, we can use the <code>kubectl plugin list</code> subcommand:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">plugin</span> <span class="keyword">list</span></span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The following kubectl-compatible plugins are <span class="string">available:</span></span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>kubectl-hello</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>kubectl-foo</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>kubectl-bar</span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># this command can also warn us about plugins that are</span></span><br><span class="line"><span class="comment"># not executable, or that are overshadowed by other</span></span><br><span class="line"><span class="comment"># plugins, for example</span></span><br><span class="line">sudo chmod -x /usr/<span class="keyword">local</span>/bin/kubectl-foo</span><br><span class="line">kubectl plugin <span class="built_in">list</span></span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The following kubectl-compatible plugins are <span class="string">available:</span></span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>kubectl-hello</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>kubectl-foo</span><br><span class="line">  - <span class="string">warning:</span> <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>kubectl-foo identified <span class="keyword">as</span> a plugin, but it is not executable</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>kubectl-bar</span><br><span class="line"><span class="string">error:</span> one plugin warning was found</span><br></pre></td></tr></table></figure><p>We can think of plugins as a means to build more complex functionality on top of the existing kubectl commands:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat ./kubectl-whoami</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># this plugin makes use of the `kubectl config` command in order to output</span></span><br><span class="line"><span class="comment"># information about the current user, based on the currently selected context</span></span><br><span class="line">kubectl<span class="built_in"> config </span>view <span class="attribute">--template</span>=<span class="string">'&#123;&#123; range .contexts &#125;&#125;&#123;&#123; if eq .name "'</span>$(kubectl<span class="built_in"> config </span>current-context)<span class="string">'" &#125;&#125;Current user: &#123;&#123; .context.user &#125;&#125;&#123;&#123; end &#125;&#125;&#123;&#123; end &#125;&#125;'</span></span><br></pre></td></tr></table></figure><p>Running the above plugin gives us an output containing the user for the currently selected context in our KUBECONFIG file:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># make the file executable</span><br><span class="line">sudo chmod +x ./kubectl-whoami</span><br><span class="line"># <span class="keyword">and</span> <span class="keyword">move</span> it <span class="keyword">into</span> our <span class="type">PATH</span></span><br><span class="line">sudo mv ./kubectl-whoami /usr/<span class="keyword">local</span>/bin</span><br><span class="line">kubectl whoami</span><br><span class="line"><span class="keyword">Current</span> <span class="keyword">user</span>: plugins-<span class="keyword">user</span></span><br></pre></td></tr></table></figure><p>To find out more about plugins, take a look at the <a href="https://github.com/kubernetes/sample-cli-plugin" rel="external nofollow noopener noreferrer" target="_blank">example cli plugin</a>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">➜ kubectl --<span class="built_in">help</span>                                                                                                        </span><br><span class="line">kubectl controls the Kubernetes cluster manager.                                                                               </span><br><span class="line">                                                                                                                               </span><br><span class="line"> Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/                                              </span><br><span class="line">                                                                                                                               </span><br><span class="line">Basic Commands (Beginner):                                                                                                     </span><br><span class="line">  create         Create a resource from a file or from stdin.                                                                  </span><br><span class="line">  expose         Take a replication controller, service, deployment or pod and expose it as a new Kubernetes Service           </span><br><span class="line">  run            Run a particular image on the cluster                                                                         </span><br><span class="line">  <span class="built_in">set</span>            Set specific features on objects                                                                              </span><br><span class="line">                                                                                                                               </span><br><span class="line">Basic Commands (Intermediate):                                                                                                 </span><br><span class="line">  explain        Documentation of resources                                                                                    </span><br><span class="line">  get            Display one or many resources                                                                                 </span><br><span class="line">  edit           Edit a resource on the server                                                                                 </span><br><span class="line">  delete         Delete resources by filenames, stdin, resources and names, or by resources and label selector                 </span><br><span class="line">                                                                                                                               </span><br><span class="line">Deploy Commands:                                                                                                               </span><br><span class="line">  rollout        Manage the rollout of a resource                                                                              </span><br><span class="line">  scale          Set a new size <span class="keyword">for</span> a Deployment, ReplicaSet, Replication Controller, or Job                                   </span><br><span class="line">  autoscale      Auto-scale a Deployment, ReplicaSet, or ReplicationController                                                 </span><br><span class="line">                                                                                                                               </span><br><span class="line">Cluster Management Commands:                                                                                                   </span><br><span class="line">  certificate    Modify certificate resources.                                                                                 </span><br><span class="line">  cluster-info   Display cluster info                                                                                          </span><br><span class="line">  top            Display Resource (CPU/Memory/Storage) usage.                                                                  </span><br><span class="line">  cordon         Mark node as unschedulable                                                                                    </span><br><span class="line">  uncordon       Mark node as schedulable                                                                                      </span><br><span class="line">  drain          Drain node <span class="keyword">in</span> preparation <span class="keyword">for</span> maintenance                                                                     </span><br><span class="line">  taint          Update the taints on one or more nodes                                                                        </span><br><span class="line">                                                                                                                               </span><br><span class="line">Troubleshooting and Debugging Commands:                                                                                        </span><br><span class="line">  describe       Show details of a specific resource or group of resources                                                     </span><br><span class="line">  logs           Print the logs <span class="keyword">for</span> a container <span class="keyword">in</span> a pod                                                                       </span><br><span class="line">  attach         Attach to a running container                                                                                 </span><br><span class="line">  <span class="built_in">exec</span>           Execute a <span class="built_in">command</span> <span class="keyword">in</span> a container                                                                              </span><br><span class="line">  port-forward   Forward one or more <span class="built_in">local</span> ports to a pod                                                                      </span><br><span class="line">  proxy          Run a proxy to the Kubernetes API server                                                                      </span><br><span class="line">  cp             Copy files and directories to and from containers.                                                            </span><br><span class="line">  auth           Inspect authorization                                                                                         </span><br><span class="line">                                                                                                                               </span><br><span class="line">Advanced Commands:                                                                                                             </span><br><span class="line">  diff           Diff live version against would-be applied version                                                            </span><br><span class="line">  apply          Apply a configuration to a resource by filename or stdin                                                      </span><br><span class="line">  patch          Update field(s) of a resource using strategic merge patch                                                     </span><br><span class="line">  replace        Replace a resource by filename or stdin                                                                       </span><br><span class="line">  <span class="built_in">wait</span>           Experimental: Wait <span class="keyword">for</span> a specific condition on one or many resources.                                         </span><br><span class="line">  convert        Convert config files between different API versions                                                           </span><br><span class="line">  kustomize      Build a kustomization target from a directory or a remote url.                                                </span><br><span class="line">                                                                                                                               </span><br><span class="line">Settings Commands:                                                                                                             </span><br><span class="line">  label          Update the labels on a resource                                                                               </span><br><span class="line">  annotate       Update the annotations on a resource                                                                          </span><br><span class="line">  completion     Output shell completion code <span class="keyword">for</span> the specified shell (bash or zsh)                                            </span><br><span class="line">                                                                                                                               </span><br><span class="line">Other Commands:                                                                                                                </span><br><span class="line">  api-resources  Print the supported API resources on the server                                                               </span><br><span class="line">  api-versions   Print the supported API versions on the server, <span class="keyword">in</span> the form of <span class="string">"group/version"</span>                                </span><br><span class="line">  config         Modify kubeconfig files                                                                                       </span><br><span class="line">  plugin         Provides utilities <span class="keyword">for</span> interacting with plugins.                                                              </span><br><span class="line">  version        Print the client and server version information                                                               </span><br><span class="line">                                                                                                                               </span><br><span class="line">Usage:                                                                                                                         </span><br><span class="line">  kubectl [flags] [options]                                                                                                    </span><br><span class="line">                                                                                                                               </span><br><span class="line">Use <span class="string">"kubectl &lt;command&gt; --help"</span> <span class="keyword">for</span> more information about a given <span class="built_in">command</span>.                                                     </span><br><span class="line">Use <span class="string">"kubectl options"</span> <span class="keyword">for</span> a list of global <span class="built_in">command</span>-line options (applies to all commands).</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubectl 是和 kubernetes 集群交互的命令行工具。 &lt;code&gt;kubectl&lt;/code&gt; 会使用 &lt;code&gt;$HOME/.kube/config&lt;/code&gt; 文件作为默认配置（也就是 kubeconfig）。我们可以通过设置环境变量 &lt;code&gt;KUBECONFIG&lt;/code&gt; 或命令行选项 &lt;code&gt;--kubeconfig&lt;/code&gt; 来指定 kubeconfig。&lt;/p&gt;
&lt;p&gt;本文概述kubectl语法，介绍命令操作，并提供常见的示例。有关每个命令的详细信息，包括所有支持的 falgs 和子命令，请参阅&lt;a href=&quot;https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;kubectl参考文档&lt;/a&gt; 。有关安装说明，请参阅&lt;a href=&quot;https://www.ikhan.top/posts/minikube-intro-and-install.html#kubectl-%E5%AE%89%E8%A3%85&quot;&gt;安装kubectl&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://www.ikhan.top/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="k8s" scheme="https://www.ikhan.top/tags/k8s/"/>
    
      <category term="kubernetes" scheme="https://www.ikhan.top/tags/kubernetes/"/>
    
      <category term="kubectl" scheme="https://www.ikhan.top/tags/kubectl/"/>
    
  </entry>
  
  <entry>
    <title>K8S互动教程2-部署一个应用</title>
    <link href="https://www.ikhan.top/posts/qrqc-basic-k8s-interactive-tutorial-2.html"/>
    <id>https://www.ikhan.top/posts/qrqc-basic-k8s-interactive-tutorial-2.html</id>
    <published>2019-05-22T11:39:35.000Z</published>
    <updated>2019-05-23T07:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是《浅入浅出k8s实战-k8s初体验篇的第三篇 》</p></blockquote><p>此文为提取大纲，按照互动教程进行分享教学用。另补充一些知识点，和关联操作。</p><p>原文：</p><ul><li>中：<a href="https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/deploy-intro/" rel="external nofollow noopener noreferrer" target="_blank">https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/deploy-intro/</a></li><li>英：<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/" rel="external nofollow noopener noreferrer" target="_blank">https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/</a></li><li>互动：<a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/" rel="external nofollow noopener noreferrer" target="_blank">https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/</a><br><a name="mnyq9"></a><h1 id="课程说明"><a href="#课程说明" class="headerlink" title="课程说明"></a>课程说明</h1></li></ul><p><a name="g0oq9"></a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>了解应用 Deployments</li><li>使用 kubectl 在 Kubernetes 上部署您的第一个应用程序</li><li>熟悉常用的 kubectl 命令</li></ul><a id="more"></a><p><a name="b9NpW"></a></p><h3 id="操作内容"><a href="#操作内容" class="headerlink" title="操作内容"></a>操作内容</h3><ul><li><p>kubectl 基础，查看 k8s 集群基本信息</p></li><li><p>命令方式部署应用</p></li><li><p>获取应用信息<br><a name="TyM7F"></a></p><h3 id="Kubernetes-Deployments"><a href="#Kubernetes-Deployments" class="headerlink" title="Kubernetes Deployments"></a>Kubernetes Deployments</h3></li><li><p>创建一个 Deployment，实际是在集群中创建 Deployment 配置，或者说把配置应用到集群中</p></li><li><p>Deployment 指示 K8S 如何去创建和更新应用程序实例</p></li><li><p>Kubernetes master 会将上述应用程序实例调度到集群中的各个 Node。</p></li><li><p>Kubernetes  Deployment Controller 会持续监视这些实例，如果托管它的 Node 不可用或被删除，则 Deployment Controller 将替换原实例为集群中其他 Node 上的新实例。（自愈机制）</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2019/svg/328984/1558525566332-b2e4462e-beaa-4b60-b41a-d5397aa78548.svg#align=left&display=inline&height=385&originHeight=385&originWidth=476&size=0&status=done&width=476" alt><br><a name="TjFxq"></a></p><h2 id="互动教程"><a href="#互动教程" class="headerlink" title="互动教程"></a>互动教程</h2><p><a name="7T2MU"></a></p><h3 id="Kubectl-基础"><a href="#Kubectl-基础" class="headerlink" title="Kubectl 基础"></a>Kubectl 基础</h3><p>kubectl 命令通常的格式是 <code>kubectl action resource</code> 。就是 <code>kubectl</code>  后跟动作/命令，紧接着是要操作的资源。而资源由类型和名称定义。详细可以参照另一篇文章<a href="https://www.ikhan.top/posts/overview-of-kubectl.html">Kubectl 命令参考</a>。<br>每一个命令都可以通过 <code>--help</code> 获得更多的信息，比如 <code>kubectl get --help</code> , <code>get</code> 是我们要经常用的命令。</p><p>首先，通过 <code>kubectl version</code> 看一下我们的 kubectl 版本信息和他所对应的集群版本信息。<br>通过 <code>kubectl get nodes</code> 看一下集群里面的节点信息。</p><p>我们这节要操作的资源是 <code>Deployment</code> ，所以我们可以先通过 <code>kubectl get deployment</code> ，如果你看过我们上面提到的<a href="https://www.ikhan.top/posts/overview-of-kubectl.html">Kubectl 命令参考</a>，你就知道，命令中的 <code>deployment</code> 属于资源类型，它的大小写，单复数并不重要。在我们集群中有了 Deployment 类型的资源后（下面的操作就会告诉你如何创建），你可以通过 <code>kubectl get deployment</code> ， <code>kubectl get deployments</code> ， <code>kubectl get deploy</code> ， <code>kubectl get Deployment</code> 等获得一样的效果。<br>如果你是新的集群，你应该看到 <code>no resources found</code> 提示，否则可能已经有一些资源存在了。记得后面的命令自己修改名字来避免重复。</p><p><a name="NVQXd"></a></p><h2 id="部署一个应用"><a href="#部署一个应用" class="headerlink" title="部署一个应用"></a>部署一个应用</h2><p><code>kubectl run</code> 命令可以创建一个 Deployment 来管理容器。其常用的命令格式是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl run NAME --image=image [--env=<span class="string">"key=value"</span>] [--port=port] [--replicas=replicas] [--dry-run=bool]</span><br><span class="line">[--overrides=inline-json] [--<span class="built_in">command</span>] -- [COMMAND] [args...] [options]</span><br></pre></td></tr></table></figure><p>参数大多根据名字就能理解，主要的两个参数，<code>NAME</code> 是 Deployment 的名字， <code>--image</code> 指定镜像。进一步理解你肯定记得 <code>--help</code> 大法。</p><p>我们接下来通过 <code>kubectl run</code> 运行一个容器 <a href="https://github.com/clarkhan/whoami" rel="external nofollow noopener noreferrer" target="_blank">registry.cn-hangzhou.aliyuncs.com/khan/whoami</a>。</p><p>这是一个可以输出 Http 请求信息的 docker 镜像，后面我们会经常使用。<br>其输出信息如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hostname :  6e0030e67d6a</span><br><span class="line">IP :  127.0.0.1</span><br><span class="line">IP :  ::1</span><br><span class="line">IP :  172.17.0.27</span><br><span class="line">IP :  fe80::42:acff:fe11:1b</span><br><span class="line"><span class="builtin-name">GET</span> / HTTP/1.1</span><br><span class="line">Host: 0.0.0.0:32769</span><br><span class="line">User-Agent: curl/7.35.0</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><p>OK，启动这个镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run first-deploy-whoami --image=registry.cn-hangzhou.aliyuncs.com/khan/whoami:1.0 --port=80</span><br></pre></td></tr></table></figure><p>我们可能会看到如下的提示信息:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="builtin-name">run</span> <span class="attribute">--generator</span>=deployment/apps.v1 is DEPRECATED <span class="keyword">and</span> will be removed <span class="keyword">in</span> a future version. Use kubectl <span class="builtin-name">run</span> <span class="attribute">--generator</span>=run-pod/v1 <span class="keyword">or</span> kubectl create instead.</span><br><span class="line">deployment.apps/first-deploy-whoami created</span><br></pre></td></tr></table></figure><p>最后是提示创建成功，然而成功提示的上面的是什么呢。容我埋个伏笔，我们稍后再解释。</p><p>成功启动容器后，我们可以通过 <code>kubectl get deployments</code> 来查看刚刚创建的资源。你应该能看到这样的输出：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                  READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">first-deploy-whoami   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">6</span>s</span><br></pre></td></tr></table></figure><p><a name="mA7Rd"></a></p><h2 id="查看你的应用"><a href="#查看你的应用" class="headerlink" title="查看你的应用"></a>查看你的应用</h2><p>容器化的应用运行在集群内部（Kubernetes 集群中，我们称之为 Pod，是最小的调度单元），使用的是集群内部的网络。这个网通通常默认是私有的隔离的，对同一个Kubernetes 集群内部其他的容器和服务可见，但是集群外并不可以。当我们使用 <code>kubectl</code> 的时候，我们是通过一个 API 端点和集群进行通信。这个 API 端点是需要额外的认证和配置的，用外部工具如 <code>curl</code> 或浏览器等没有权限。</p><p>后续，我们会在互动教程4中来看如何通过其他的方式把应用（Pod）暴露到 kubernetes 集群之外。此节我们先通过 API 的本地 proxy 来实现。</p><p><code>kube proxy</code> 命令能够创建一个本地的代理，转发通信请求到集群的私有网络。control-C可以关闭这个代理。<br>我们启动这个代理，默认情况下是绑定到 8001 端口，我们可以改为其他段扣，此处指定 8081：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl<span class="built_in"> proxy </span>--port 8081</span><br></pre></td></tr></table></figure><p>然后我们通过 <a href="http://localhost:8081/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8081</a> 就可以访问到这个服务器信息，其会返回 JSON 格式的接口列表信息。可以通过 <code>[http://localhost:8081/version](http://localhost:8081/version)</code> 访问到版本号信息，和我们 <code>kubectl version</code> 拿到的服务器信息一致。</p><p>API Server 会自动地为每个 Pod 创建一个基于 Pod 名称的可访问端点。首先，我们需要获取这个 Pod 的名称。将其存储到上下文变量 POD_NAME 中，由于上一个命令行正在运行 proxy，我们打开新的命令行运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POD_NAME=$(kubectl get pods -o go-template --template <span class="string">'&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;"\n"&#125;&#125;&#123;&#123;end&#125;&#125;'</span>)</span><br></pre></td></tr></table></figure><p>现在，我们可以通过 Http 请求来访问这个pod：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8081/api/v1/namespaces/default/pods/<span class="variable">$POD_NAME</span>/proxy/</span><br></pre></td></tr></table></figure><p>应该可以输出如下的信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Hostname:</span> <span class="string">first-deploy-whoami-68dd7db55-bpr52</span></span><br><span class="line"><span class="attr">IP:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">IP:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/</span> <span class="string">HTTP/1.1</span></span><br><span class="line"><span class="attr">Host:</span> <span class="string">localhost:8081</span></span><br><span class="line"><span class="attr">User-Agent:</span> <span class="string">curl/7.58.0</span></span><br><span class="line"><span class="attr">Accept:</span> <span class="string">*/*</span></span><br><span class="line"><span class="attr">Accept-Encoding:</span> <span class="string">gzip</span></span><br><span class="line"><span class="attr">X-Forwarded-For:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">,</span> <span class="number">192.168</span><span class="number">.99</span><span class="number">.1</span></span><br><span class="line"><span class="attr">X-Forwarded-Uri:</span> <span class="string">/api/v1/namespaces/default/pods/first-deploy-whoami-68dd7db55-bpr52/proxy/</span></span><br></pre></td></tr></table></figure><p>你也可以通过浏览器访问 <a href="http://localhost:8081/api/v1/namespaces/default/pods/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8081/api/v1/namespaces/default/pods/</a> 可以看到所有 pod，然后将名称复制下来，组成同样的链接访问。</p><p>在上面的信息中，我们可以看到， <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Uri</code> 两个应用收到的请求头表名这是一个通过代理的访问。</p><p><a name="W7Xyp"></a></p><h2 id="结束你的应用"><a href="#结束你的应用" class="headerlink" title="结束你的应用"></a>结束你的应用</h2><p>可以通过 <code>kubectl delete</code> 命令删除我们刚刚的 Deployment：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete deployment fisrt-deploy-whoami</span><br></pre></td></tr></table></figure><p>命令简单易懂，就不再解释了。</p><p><a name="aRkWf"></a></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>回到上面我们埋下的伏笔， <code>kubectl run</code> 中 <code>DEPRECATED</code> 的信息。其文档中有说明</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> --generator=<span class="string">''</span>: The name of the API generator to use, see</span><br><span class="line">http:<span class="regexp">//</span>kubernetes.io<span class="regexp">/docs/u</span>ser-guide<span class="regexp">/kubectl-conventions/</span><span class="comment">#generators for a list.</span></span><br></pre></td></tr></table></figure><p>实际上， <code>--generator</code> 是指示  <code>kubectl run</code> 命令最终生成什么资源。用不用的生成器，生成的资源就不同。目前（1.14.2）默认生成器是 <code>deployment/apps.v1</code> <br>我们可以访问 <a href="https://kubernetes.io/docs/reference/kubectl/conventions/#generators" rel="external nofollow noopener noreferrer" target="_blank">https://kubernetes.io/docs/reference/kubectl/conventions/#generators</a> 查看所有的生成器。<br>如果切换为如下的命令，将不再有提示，但请注意命令执行后的描述，而且，执行这条命令并不会和同名的 deployment 冲突，之前的 deployment删除和不删除都无印象。你能知道为什么以及如何查看新生产的资源吗？</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="builtin-name">run</span> first-deploy-whoami <span class="attribute">--image</span>=registry.cn-hangzhou.aliyuncs.com/khan/whoami:1.0 <span class="attribute">--port</span>=80 <span class="attribute">--generator</span>=run-pod/v1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是《浅入浅出k8s实战-k8s初体验篇的第三篇 》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此文为提取大纲，按照互动教程进行分享教学用。另补充一些知识点，和关联操作。&lt;/p&gt;
&lt;p&gt;原文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中：&lt;a href=&quot;https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/deploy-intro/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/deploy-intro/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;英：&lt;a href=&quot;https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;互动：&lt;a href=&quot;https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/&lt;/a&gt;&lt;br&gt;&lt;a name=&quot;mnyq9&quot;&gt;&lt;/a&gt;&lt;h1 id=&quot;课程说明&quot;&gt;&lt;a href=&quot;#课程说明&quot; class=&quot;headerlink&quot; title=&quot;课程说明&quot;&gt;&lt;/a&gt;课程说明&lt;/h1&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name=&quot;g0oq9&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;了解应用 Deployments&lt;/li&gt;
&lt;li&gt;使用 kubectl 在 Kubernetes 上部署您的第一个应用程序&lt;/li&gt;
&lt;li&gt;熟悉常用的 kubectl 命令&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="容器,浅入浅出k8s实战" scheme="https://www.ikhan.top/categories/%E5%AE%B9%E5%99%A8-%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAk8s%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="k8s" scheme="https://www.ikhan.top/tags/k8s/"/>
    
      <category term="kubernetes" scheme="https://www.ikhan.top/tags/kubernetes/"/>
    
      <category term="浅入浅出k8s实战" scheme="https://www.ikhan.top/tags/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAk8s%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Spinnaker 部署 CRD 资源</title>
    <link href="https://www.ikhan.top/posts/spinnaker-deploy-crd.html"/>
    <id>https://www.ikhan.top/posts/spinnaker-deploy-crd.html</id>
    <published>2019-05-21T11:39:35.000Z</published>
    <updated>2019-05-22T03:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>我使用的 Spinnaker 版本（1.12.10 Unbreakable）中部署 <code>IngressRoute</code> 类型资源的时候遇到错误，通过查找相关资料测试，发现 CRD 需要额外的配置。其他的版本可能也存在同样的情况，此文记录相关信息及如何解决。</p><a id="more"></a><p><a name="l6Npk"></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>部署自定义资源失败，提示信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception ( Monitor Deploy )</span><br><span class="line">Unsupported Kubernetes object kind <span class="string">'IngressRoute'</span>, unable to <span class="built_in">continue</span>.</span><br></pre></td></tr></table></figure><p>在官方的 Issues 中找到了类似的问题：</p><ul><li><a href="https://github.com/spinnaker/spinnaker/issues/3439" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/spinnaker/spinnaker/issues/3439</a></li><li><a href="https://github.com/spinnaker/spinnaker/issues/4356" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/spinnaker/spinnaker/issues/4356</a></li><li><a href="https://github.com/spinnaker/spinnaker/issues/4237" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/spinnaker/spinnaker/issues/4237</a><br><a name="Ki19X"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2></li></ul><p>可以看到，一开始是的确有 bug 的，但后来修复了。然后我根据 issue 中提到的需要配置的<code>customResources</code> <br> 到官方文档中搜索，没有搜索到有用的信息。又通过 <code>Halyard</code>  的命令行帮助也没有查找到有相关设置 <code>customResources</code>  的地方…… 这就很迷了啊，难道手工改 <code>~/.hal/config</code> 么，总感觉不太对。<br> <br>之后就发现了这个 issue：<a href="https://github.com/spinnaker/spinnaker/issues/4345" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/spinnaker/spinnaker/issues/4345</a><br>果然，官方就是没有提供对应的操作命令。</p><p>要解决这个问题，需要满足：</p><ul><li>spinnaker 的 kubernetes provider 使用的 account 有对应CRD的读取权限，这个根据 kubernetes 的 RBAC 配置方式很容易搞定。</li><li>Halyard 的配置文件中 ~/.hal/config 使用的 account 下 <code>customResources</code> 定义了对应的资源</li></ul><p>我是手工修改该配置的，大概就是如下这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploymentConfigurations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">providers:</span></span><br><span class="line">    <span class="attr">kubernetes:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">accounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-k8s-v2-account</span></span><br><span class="line">          <span class="attr">requiredGroupMembership:</span> <span class="string">[]</span></span><br><span class="line">          <span class="attr">providerVersion:</span> <span class="string">V2</span></span><br><span class="line">          <span class="attr">permissions:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">          <span class="attr">dockerRegistries:</span> <span class="string">[]</span></span><br><span class="line">          <span class="attr">context:</span> <span class="string">focus</span></span><br><span class="line">          <span class="attr">configureImagePullSecrets:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">cacheThreads:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">namespaces:</span> <span class="string">[]</span></span><br><span class="line">          <span class="attr">omitNamespaces:</span> <span class="string">[]</span></span><br><span class="line">          <span class="attr">kinds:</span> <span class="string">[]</span></span><br><span class="line">          <span class="attr">omitKinds:</span> <span class="string">[]</span></span><br><span class="line">          <span class="attr">customResources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">kubernetesKind:</span> <span class="string">ingressroutes.traefik.containo.us</span></span><br><span class="line">          <span class="attr">cachingPolicies:</span> <span class="string">[]</span></span><br></pre></td></tr></table></figure><p>其他无关配置忽略了，就是在 deploymentConfigurations -&gt; providers -&gt;kubernetes -&gt; customResources 下添加自定义资源列表就 ok 了。</p><p>配置后，通过 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hal deploy apply</span><br></pre></td></tr></table></figure><p>重新部署，就可以支持了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我使用的 Spinnaker 版本（1.12.10 Unbreakable）中部署 &lt;code&gt;IngressRoute&lt;/code&gt; 类型资源的时候遇到错误，通过查找相关资料测试，发现 CRD 需要额外的配置。其他的版本可能也存在同样的情况，此文记录相关信息及如何解决。&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://www.ikhan.top/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="k8s" scheme="https://www.ikhan.top/tags/k8s/"/>
    
      <category term="kubernetes" scheme="https://www.ikhan.top/tags/kubernetes/"/>
    
      <category term="spinnaker" scheme="https://www.ikhan.top/tags/spinnaker/"/>
    
  </entry>
  
  <entry>
    <title>rancher、spinnaker对helm chart的相对路径解析问题</title>
    <link href="https://www.ikhan.top/posts/rancher-spinnaker-relative-chart-error.html"/>
    <id>https://www.ikhan.top/posts/rancher-spinnaker-relative-chart-error.html</id>
    <published>2019-05-21T01:38:04.000Z</published>
    <updated>2019-05-21T01:38:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前（2019年5月21日） rancher 和 spinnaker 最新版本对 helm chart 仓库中的包相对路径解析存在一点问题。<br>rancher 会报：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Helm template failed. Error: <span class="built_in">stat</span> template-dir: no such file or directory : <span class="built_in">exit</span> status 1</span><br></pre></td></tr></table></figure><p>spinnaker 则无法正确解析 artifact：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.netflix.spinnaker.clouddriver.artifacts.helm.HelmArtifactCredentials<span class="variable">$FailedDownloadException</span>: Unable to download the contents of artifact</span><br></pre></td></tr></table></figure><p>我们来看看怎么解决~<br><a id="more"></a></p><p>该问题官方 Issues 中已有提出：</p><ul><li><a href="https://github.com/spinnaker/spinnaker/issues/4078" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/spinnaker/spinnaker/issues/4078</a> spinnaker已解决，但是要在 1.14 发布</li><li><a href="https://github.com/rancher/rancher/issues/18535" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/rancher/rancher/issues/18535</a> rancher 很早报告了该问题，但迟迟无响应</li></ul><p>除了等待官方的兼容之外，如果我们用的自己的私库，可控的话，可是考虑通过配置使生成的 <code>index.yaml</code> 为绝对路径来解决。</p><p><a name="49gg4"></a></p><h2 id="chartmuseum-配置绝对路径"><a href="#chartmuseum-配置绝对路径" class="headerlink" title="chartmuseum 配置绝对路径"></a>chartmuseum 配置绝对路径</h2><p>通过 <code>chartmuseum --help</code> 命令我们可以看到 <code>chartmuseum</code> 支持 <code>--chart-url value</code> 这样的一个配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--chart-url value                     absolute url <span class="keyword">for</span> .tgzs <span class="keyword">in</span> index.yaml [<span class="variable">$CHART_URL</span>]</span><br></pre></td></tr></table></figure><p>即，可以通过这个参数指定 <code>index.yaml</code> 中的 <code>.tgzs</code> 包绝对路径。<br>所以，如果你通过二进制运行,则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chartmuseum  --port 8080 --storage <span class="built_in">local</span> --storage-local-rootdir /path/to/charts --chart-url http://host:8080</span><br></pre></td></tr></table></figure><p>。如果通过 <code>docker</code> 方式运行则这样指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  -e STORAGE=<span class="built_in">local</span> \</span><br><span class="line">  -e STORAGE_LOCAL_ROOTDIR=/charts \</span><br><span class="line">  chartmuseum/chartmuseum:latest --chart-url http://host:8080</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前（2019年5月21日） rancher 和 spinnaker 最新版本对 helm chart 仓库中的包相对路径解析存在一点问题。&lt;br&gt;rancher 会报：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Helm template failed. Error: &lt;span class=&quot;built_in&quot;&gt;stat&lt;/span&gt; template-dir: no such file or directory : &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt; status 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;spinnaker 则无法正确解析 artifact：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;com.netflix.spinnaker.clouddriver.artifacts.helm.HelmArtifactCredentials&lt;span class=&quot;variable&quot;&gt;$FailedDownloadException&lt;/span&gt;: Unable to download the contents of artifact&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们来看看怎么解决~&lt;br&gt;
    
    </summary>
    
      <category term="容器" scheme="https://www.ikhan.top/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="helm" scheme="https://www.ikhan.top/tags/helm/"/>
    
      <category term="k8s" scheme="https://www.ikhan.top/tags/k8s/"/>
    
      <category term="kubernetes" scheme="https://www.ikhan.top/tags/kubernetes/"/>
    
      <category term="spinnaker" scheme="https://www.ikhan.top/tags/spinnaker/"/>
    
      <category term="rancker" scheme="https://www.ikhan.top/tags/rancker/"/>
    
      <category term="chart" scheme="https://www.ikhan.top/tags/chart/"/>
    
  </entry>
  
  <entry>
    <title>Helm 介绍和安装</title>
    <link href="https://www.ikhan.top/posts/helm-intro-and-install.html"/>
    <id>https://www.ikhan.top/posts/helm-intro-and-install.html</id>
    <published>2019-05-06T11:45:11.000Z</published>
    <updated>2019-05-20T12:30:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Helm 是由 Deis 发起的一个开源工具，有助于简化部署和管理 Kubernetes 应用。本文介绍了 helm 的基本概念和安装方法，针对国内网络情况提供阿里的 helm charts 仓库。<br></p><a id="more"></a><p>注：阿里云Kubernetes服务已经内置提供了Helm/Chart支持，可以直接使用<br><a href="https://help.aliyun.com/document_detail/58587.html" rel="external nofollow noopener noreferrer" target="_blank">https://help.aliyun.com/document_detail/58587.html</a></p><p><a name="0d5fcd68"></a></p><h2 id="Helm-基本概念"><a href="#Helm-基本概念" class="headerlink" title="Helm 基本概念"></a>Helm 基本概念</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1558417320441-4689f936-d217-4c13-839c-ecac46a04f87.png#align=left&display=inline&height=576&originHeight=576&originWidth=788&size=0&status=done&width=788" alt></p><p>Helm 可以理解为 Kubernetes 的包管理工具，可以方便地发现、共享和使用为Kubernetes构建的应用，它包含几个基本概念</p><ul><li>Chart：一个 Helm 包，其中包含了运行一个应用所需要的镜像、依赖和资源定义等，还可能包含 Kubernetes 集群中的服务定义，类似 Homebrew 中的 formula，APT 的 dpkg 或者 Yum 的 rpm 文件，</li><li>Release: 在 Kubernetes 集群上运行的 Chart 的一个实例。在同一个集群上，一个 Chart 可以安装很多次。每次安装都会创建一个新的 release。例如一个 MySQL Chart，如果想在服务器上运行两个数据库，就可以把这个 Chart 安装两次。每次安装都会生成自己的 Release，会有自己的 Release 名称。</li><li>Repository：用于发布和存储 Chart 的仓库。</li></ul><p><a name="3718f9d3"></a></p><h2 id="Helm-组件"><a href="#Helm-组件" class="headerlink" title="Helm 组件"></a>Helm 组件</h2><p>Helm 采用客户端/服务器架构，有如下组件组成：</p><ul><li>Helm CLI 是 Helm 客户端，可以在本地执行</li><li>Tiller 是服务器端组件，在 Kubernetes 群集上运行，并管理 Kubernetes 应用程序的生命周期</li><li>Repository 是 Chart 仓库，Helm客户端通过HTTP协议来访问仓库中Chart的索引文件和压缩包。<br><br>15019325767895</li></ul><p><a name="Eujrz"></a></p><h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><p>因为 helm 服务端（Tiller）是部署在 k8s 集群上面，客户端需要的 k8s 集群信息就是本地的集群信息。所以需要预先安装 kubectl ，配置好 k8s 集群通信。</p><p>安装方式可参考<a href="https://www.ikhan.top/posts/minikube-intro-and-install.html#kubectl-%E5%AE%89%E8%A3%85">Kubernetes 本地测试环境 MiniKube 介绍及国内安装配置#kubectl 安装</a>一节。<br>如果是 minikube 集群则 minikube 会自动配置集群信息，其他集群请从集群管理员获得集群信息配置在 ~/.kube/config 中。</p><p>配置后，通过 <code>kubectl cluster-info</code> 检查是否OK。</p><p><a name="6dab15a2"></a></p><h2 id="安装-helm-client"><a href="#安装-helm-client" class="headerlink" title="安装 helm client"></a>安装 helm client</h2><p>参照官方文档：<a href="https://helm.sh/docs/using_helm/#installing-helm" rel="external nofollow noopener noreferrer" target="_blank">https://helm.sh/docs/using_helm/#installing-helm</a></p><ol><li>官方 release 地址 <a href="https://github.com/helm/helm/releases" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/helm/helm/releases</a> 下载。</li><li>解压 <code>tar -zxvf helm-v2.0.0-linux-amd64.tgz</code></li><li>将 <code>helm</code> 放到执行路径 <code>mv linux-amd64/helm /usr/local/bin/helm</code></li></ol><p>搞定。</p><p>此时如果不需要安装服务端（Tiller）的话我们通过如下命令来初始化客户端就ok：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm init --client-only --stable-repo-url https://aliacs-app-catalog.oss-cn-hangzhou.aliyuncs.com/charts/</span><br><span class="line">helm repo add incubator https://aliacs-app-catalog.oss-cn-hangzhou.aliyuncs.com/charts-incubator/</span><br><span class="line">helm repo update</span><br></pre></td></tr></table></figure><p>chart 仓库使用： <a href="https://aliacs-app-catalog.oss-cn-hangzhou.aliyuncs.com/charts/" rel="external nofollow noopener noreferrer" target="_blank">https://aliacs-app-catalog.oss-cn-hangzhou.aliyuncs.com/charts/</a>,参考的是阿里的 <a href="https://www.alibabacloud.com/help/zh/doc-detail/58587.htm#h2-url-6" rel="external nofollow noopener noreferrer" target="_blank">helm 文档</a>。</p><p><a name="4ef10750"></a></p><h2 id="安装-TILLER"><a href="#安装-TILLER" class="headerlink" title="安装 TILLER"></a>安装 TILLER</h2><p>官方文档：<a href="https://helm.sh/docs/using_helm/#installing-tiller" rel="external nofollow noopener noreferrer" target="_blank">https://helm.sh/docs/using_helm/#installing-tiller</a></p><p>这个由于要下载镜像，国内网络你懂的。索性阿里提供国内镜像，所以参照阿里的文章: <a href="https://yq.aliyun.com/articles/159601" rel="external nofollow noopener noreferrer" target="_blank">利用Helm简化Kubernetes应用部署</a> 安装。</p><p>其中镜像在阿里云杭州区的 <code>google_containers/tiler</code> 仓库 <a href="https://cr.console.aliyun.com/images/cn-hangzhou/google_containers/tiller/detail" rel="external nofollow noopener noreferrer" target="_blank">https://cr.console.aliyun.com/images/cn-hangzhou/google_containers/tiller/detail</a></p><ol><li>执行命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm init --upgrade -i registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1 --stable-repo-url https://aliacs-app-catalog.oss-cn-hangzhou.aliyuncs.com/charts/</span><br></pre></td></tr></table></figure><ol start="2"><li>rbac 配置。自Kubernetes 1.6版本开始，API Server启用了RBAC授权。依次执行如下命令:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create serviceaccount --namespace kube-system tiller</span><br><span class="line">kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller</span><br><span class="line">kubectl patch deploy --namespace kube-system tiller-deploy -p <span class="string">'&#123;"spec":&#123;"template":&#123;"spec":&#123;"serviceAccount":"tiller"&#125;&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure><p>前两行也可以替换为应用 k8s 配置：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure><p><a name="29b5df07"></a></p><h2 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helm version</span><br><span class="line">helm search</span><br><span class="line">helm ls</span><br><span class="line"><span class="comment">## 更多命令参考 helm --help</span></span><br></pre></td></tr></table></figure><p><a name="dc92a888"></a></p><h2 id="公共仓库"><a href="#公共仓库" class="headerlink" title="公共仓库"></a>公共仓库</h2><p>微软也提供了helm 仓库的镜像, 找到这儿的朋友推荐使用微软的镜像：</p><ul><li>stable: <a href="http://mirror.azure.cn/kubernetes/charts/" rel="external nofollow noopener noreferrer" target="_blank">http://mirror.azure.cn/kubernetes/charts/</a></li><li>incubator: <a href="http://mirror.azure.cn/kubernetes/charts-incubator/" rel="external nofollow noopener noreferrer" target="_blank">http://mirror.azure.cn/kubernetes/charts-incubator/</a></li></ul><p><a name="d43475a2"></a></p><h2 id="参考信息"><a href="#参考信息" class="headerlink" title="参考信息"></a>参考信息</h2><p>Helm 催生了社区的发展壮大，越来越多的软件提供商，如 Bitnami 等公司，开始提供高质量的 Charts。您可以在 <a href="https://kubeapps.com/" rel="external nofollow noopener noreferrer" target="_blank">https://kubeapps.com/</a> 中寻找和发现已有的 Charts。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Helm 是由 Deis 发起的一个开源工具，有助于简化部署和管理 Kubernetes 应用。本文介绍了 helm 的基本概念和安装方法，针对国内网络情况提供阿里的 helm charts 仓库。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://www.ikhan.top/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="helm" scheme="https://www.ikhan.top/tags/helm/"/>
    
      <category term="k8s" scheme="https://www.ikhan.top/tags/k8s/"/>
    
      <category term="kubernetes" scheme="https://www.ikhan.top/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Traefik 2.0 介绍</title>
    <link href="https://www.ikhan.top/posts/traefik-2_0-intro.html"/>
    <id>https://www.ikhan.top/posts/traefik-2_0-intro.html</id>
    <published>2019-04-29T13:30:24.000Z</published>
    <updated>2019-07-01T11:40:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>traefik 是一个开源的反向代理和负载均衡工具，现在官方介绍中将其定位为云原生的边缘路由器，且用了一堆修饰词：简单、自动、高速、全面、开源、产品级、内置监控指标和主流集群技术集成等等。<br>当然，官方如此描述也是有理有据的，其开源后热度直线上升，而且被广泛使用，尤其是在当下的“微服务”、“云原生”场景。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1561945084301-b70060bb-6a79-423b-8569-f4c526b6c340.png#align=left&display=inline&height=1501&originHeight=1501&originWidth=2875&size=0&status=done&width=2875" alt><br>从我个人的角度讲，其相对于传统的反向代理显得更“现代”：</p><ul><li>动态的更新配置，不需要重启/reload等操作。</li><li>原生支持Docker, Swarm mode, Kubernetes, Marathon, Consul, Etcd, Rancher, Amazon ECS等等后端。</li><li>支持 RestAPI</li><li>支持后端健康状态检查，根据状态自动地配置</li></ul><p>这些特点，让其在云原生的场景下更贴合。而traefik本身的特性远不止如此。大家有兴趣可阅读它的官方文档：<a href="https://docs.traefik.io/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.traefik.io/</a>，而且国内的资料介绍也很多。<br>本篇文章的背景是因为工作中用到了版本2中的一些特性，但国内关于新版的介绍资料较少，遂对 <a href="https://blog.containo.us/back-to-traefik-2-0-2f9aa17be305" rel="external nofollow noopener noreferrer" target="_blank">back to traefik 2.0</a> 这篇文章的核心部分做了简单翻译提取。如有理解错漏，请指正。</p><p>目前（2019年5月21日）2.0 正在开发中，alpha4 版本在 4月17日发布。我们一起看看 2.0 有哪些东西。</p><a id="more"></a><p><a name="2af44481"></a></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1558438336494-7126bbfb-8fe7-4cbf-9da4-b94ffcb4ee77.png#align=left&display=inline&height=940&originHeight=940&originWidth=2000&size=0&status=done&width=2000" alt></p><ul><li>Providers 是指你正在使用的集群技术 (Kubernetes, Docker, Consul, Mesos, Rancher…). Traefik 通过 provider 的 API 来发现对应到你的服务的 routes（路由）.</li><li>Entrypoints, 是最基本的配置，指监听请求的端口.</li><li>Services 是在你的基础设施上的运行的软件的体现. Traefik 知道如何处理你的程序的多个实例(当前提供多种负载均衡的能力/方法), 然后通过 services 配置如何联通到真实的运行程序.</li><li>Routers 将传入的请求和你的 service 连接起来. 他们持有的 rules 决定哪个 service 将处理对应的请求.</li><li>最后, 中间件是可以在请求被 service 处理之前对其进行更新的组件.Traefik 提供了一些开箱即用的中间件来处理 认证、速率限制、断路器、白名单、缓冲等等.</li></ul><p><a name="746fffa9"></a></p><h2 id="配置结构"><a href="#配置结构" class="headerlink" title="配置结构"></a>配置结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1558438336566-c7a38b11-fffb-4873-85d2-b6727562f510.png#align=left&display=inline&height=1027&originHeight=1027&originWidth=1600&size=0&status=done&width=1600" alt></p><p>从图中可以看到，配置氛围静态配置和动态配置。</p><ul><li>静态配置，启动的时候加载。包括 Entrypoints、Provider 连接信息</li><li>动态配置，运行时可动态读取改变的。包括 Routes、Services、Middlewares、Certificates 。</li></ul><p><a name="6073d869"></a></p><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><p><a name="f8332bf8"></a></p><h3 id="TCP-支持"><a href="#TCP-支持" class="headerlink" title="TCP 支持"></a>TCP 支持</h3><p>历时三年，经过大量的讨论和开发，目前 traefik 完全支持 TCP 协议。</p><p>示例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[entrypoints]</span></span><br><span class="line">   <span class="section">[entrypoints.web]</span></span><br><span class="line">      address = ":80"</span><br><span class="line"><span class="section">[entrypoints.mongo-port]</span></span><br><span class="line">      address = ":27017"</span><br><span class="line"><span class="section">[tcp]</span> <span class="comment"># YAY!</span></span><br><span class="line">   <span class="section">[tcp.routers]</span></span><br><span class="line">      <span class="section">[tcp.routers.everything-to-mongo]</span></span><br><span class="line">         entrypoints = ["mongo-port"]</span><br><span class="line">         rule = "HostSNI(`*`)" # Catches every request       </span><br><span class="line">         service = "database"</span><br></pre></td></tr></table></figure><p>使用 FileProvider，重定向所有 27010 端口的请求到数据库服务。</p><p>来看更厉害的，Traefik 支持基于 SNIs 的路由：</p><blockquote><p>服务器名称指示(SNI)是TLS计算机网络协议的扩展，通过该协议，客户机在握手过程开始时指示要连接到哪个主机名。这允许服务器在相同的IP地址和TCP端口号上显示多个证书，因此允许由相同的IP地址提供多个安全(HTTPS)站点(或TLS上的任何其他服务)，而不需要所有这些站点使用相同的证书。它在概念上等同于HTTP/1.1基于名称的虚拟主机，但适用于HTTPS。所需的主机名在原始SNI扩展中没有加密，因此窃听者可以看到请求的是哪个站点。</p></blockquote><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[entrypoints]</span></span><br><span class="line">   <span class="section">[entrypoints.web]</span></span><br><span class="line">      address = ":80"</span><br><span class="line"><span class="section">[entrypoints.mongo-port]</span></span><br><span class="line">      address = ":27017"</span><br><span class="line"><span class="section">[tcp]</span> <span class="comment"># YAY!</span></span><br><span class="line">   <span class="section">[tcp.routers]</span></span><br><span class="line">      <span class="section">[tcp.routers.to-db-1]</span></span><br><span class="line">         entrypoints = ["mongo-port"]</span><br><span class="line">         rule = "HostSNI(`db-1.domain`)"       </span><br><span class="line">         service = "db-1"</span><br><span class="line">         <span class="section">[tcp.routers.to-db-1.tls]</span> <span class="comment"># The route is for TLS requests only</span></span><br><span class="line">      <span class="section">[tcp.routers.to-db-2]</span></span><br><span class="line">         entrypoints = ["mongo-port"]</span><br><span class="line">         rule = "HostSNI(`db-2.domain`)"       </span><br><span class="line">         service = "db-2"</span><br><span class="line">         <span class="section">[tcp.routers.to-db-2.tls]</span> <span class="comment"># The route is for TLS requests only</span></span><br></pre></td></tr></table></figure><p>更更厉害的呢？Traefik 可以牛到在同一个端口上同时支持 HTTP 和 TCP。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[entrypoints]</span></span><br><span class="line">   <span class="section">[entrypoints.the-one]</span></span><br><span class="line">      address = ":443"</span><br><span class="line"><span class="section">[tcp]</span></span><br><span class="line">   <span class="section">[tcp.routers]</span></span><br><span class="line">      <span class="section">[tcp.routers.to-db-1]</span></span><br><span class="line">         rule = "HostSNI(`db-1.domain`)"       </span><br><span class="line">         service = "db-1"</span><br><span class="line">         <span class="section">[tcp.routers.to-db-1.tls]</span> <span class="comment"># The route is for TLS requests only</span></span><br><span class="line"><span class="section">[http]</span></span><br><span class="line">   <span class="section">[http.routers]</span></span><br><span class="line">      <span class="section">[http.routers.my-api]</span></span><br><span class="line">         rule = "Host(`api.domain`)"       </span><br><span class="line">         service = "my-api"</span><br></pre></td></tr></table></figure><p>在它的第一个alpha版本中，Traefik 只在 FileProvider 中可以启用TCP路由，但是请做好准备，因为它很快就会对其他 Providers 可用!</p><p><a name="c17b78cc"></a></p><h3 id="用来更新请求的中间件（Middlewares）"><a href="#用来更新请求的中间件（Middlewares）" class="headerlink" title="用来更新请求的中间件（Middlewares）"></a>用来更新请求的中间件（Middlewares）</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1558438336288-f5992809-8871-4b2f-9df9-47d75dc9c155.png#align=left&display=inline&height=983&originHeight=983&originWidth=1800&size=0&status=done&width=1800" alt></p><p>过去很多特性被嵌入到 Traefik 中，但没有针对性的定制和对应选项去调整。</p><p>Middlewares 填补了这一空白。你可以做到针对每一个 router 开启和调整相关特性。</p><p>Middlewares 是在请求实际转发到服务之前对其进行操作的组件，如果不满足要求的条件，甚至可以决定不转发请求。</p><p>在发布时，Traefik附带了以下中间件:</p><ul><li>AddPrefix(给请求添加一个前缀路径)</li><li>BasicAuth</li><li>DigestAuth</li><li>ForwardAuth(委托第三方服务身份验证)</li><li>Buffering</li><li>Chain (定义可重用的Middleware集和)</li><li>CircuitBreaker (断路器，避免调用压垮服务)</li><li>Compress</li><li>Errors(提供自定义的错误页面)</li><li>Headers</li><li>IpWhitelist</li><li>MaxConn(限制连接到服务的并发连接数)</li><li>PassTLSClientCert</li><li>RateLimit(在给定时间段内限制对服务的请求数量)</li><li>RedirectRegex</li><li>RedirectScheme</li><li>ReplacePath(在转发到服务之前更新请求路径)。</li></ul><p>更重要的，项目重构了代码，使未来更方便地提供更多的中间件。</p><p><a name="74f39680"></a></p><h3 id="Kubernetes-amp-CRD（CustomResourceDefinition）"><a href="#Kubernetes-amp-CRD（CustomResourceDefinition）" class="headerlink" title="Kubernetes &amp; CRD（CustomResourceDefinition）"></a>Kubernetes &amp; CRD（CustomResourceDefinition）</h3><p>在过去两年里，社区围绕“更好的 ingress”进行了大量的讨论，回看之前的 kubernettes provider，我们认为还有改进的空间。对于V2，如果我们想让 k8s 用户直接从中受益（比如 TCP 和 middleware），而不被大量 annotations 困扰，我们必须提供新的选择。</p><p>在备选方案中，CRD 越来越受欢迎，因为它们解决了ingress规范的缺点。受 Heptio 在 Contour 项目中的 IngressRoute 启发，我们扩展了这个规范来实现每个Traefik特性。</p><p>下面是一个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">traefik.containo.us/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test.crd</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">entrypoints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">web</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">web-secure</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">match:</span> <span class="string">Host(`traefik.io`)</span> <span class="string">&amp;&amp;</span> <span class="string">PathPrefix(`/foo`)</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">Rule</span></span><br><span class="line">      <span class="attr">services:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whoami1</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">strategy:</span> <span class="string">RoundRobin</span></span><br><span class="line">      <span class="attr">middlewares:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">stripprefix</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">addprefix</span></span><br><span class="line">          <span class="attr">namespace:</span> <span class="string">foo</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">match:</span> <span class="string">Host(`containo.us`)</span> <span class="string">&amp;&amp;</span> <span class="string">Method(`POST`)</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">Rule</span></span><br><span class="line">      <span class="attr">services:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whoami2</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">supersecret</span></span><br></pre></td></tr></table></figure><p><a name="a5d46ed6"></a></p><h3 id="新的更有表现力的路由规则语法"><a href="#新的更有表现力的路由规则语法" class="headerlink" title="新的更有表现力的路由规则语法"></a>新的更有表现力的路由规则语法</h3><p>Traefik 现在支持更有表现力的语法来定义 router rules，包含 <code>and</code>, <code>or</code> 和 <code>parenthesis</code>（括号）！</p><p>可用的 matchers 有 Headers, HeadersRegexp, Host, HostRegexp, Method, Path, PathPrefix, and Query.</p><p>由于 TCP 是完全不同的东东，所以目前只支持专用的 matcher：HostSNI。<br>Since TCP is a whole different world, for now, it only supports a dedicated matcher: HostSNI.</p><p>来看个例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rule = (<span class="constructor">Host(`<span class="params">api</span>.<span class="params">domain</span>`)</span><span class="operator"> &amp;&amp; </span><span class="constructor">PathPrefix(`<span class="operator">/</span><span class="params">v2</span>`)</span>)<span class="operator"> || </span><span class="constructor">Host(`<span class="params">api</span>-<span class="params">v2</span>.<span class="params">domain</span>`)</span></span><br><span class="line">rule = (<span class="constructor">Method(`DELETE`)</span><span class="operator"> || </span>(<span class="constructor">Method(`POST`)</span><span class="operator"> &amp;&amp; </span><span class="constructor">Query(`<span class="params">action</span>`, `<span class="params">delete</span>`)</span>))<span class="operator"> &amp;&amp; </span><span class="constructor">Host('<span class="params">api</span>.<span class="params">domain</span>')</span></span><br></pre></td></tr></table></figure><p><a name="90aeab21"></a></p><h3 id="Cross-Provider"><a href="#Cross-Provider" class="headerlink" title="Cross Provider"></a>Cross Provider</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1558438336484-9c7f3b19-8a4e-40c0-b974-3f31b006dc78.png#align=left&display=inline&height=1064&originHeight=1064&originWidth=1600&size=0&status=done&width=1600" alt></p><p>Traefik 一直与很多 providers 兼容, 这是他的优势之一：无论你的基础设施是什么，从裸机到各种协调器和集群方案，Traefik 都能搞定!</p><p>但从 V2 开始，我们更进一步做到了让用户在一个 provider 中声明元素（middlewares, services, routers）在其他不同的 provider 中使用。</p><p>让我们来看一个例子，例子中在配置文件中（file provider）声明了一个认证 middleware，在 Docker label（Docker Provider）中被使用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># somewhere in a configuration file for the file provider</span></span><br><span class="line"><span class="section">[http.middlewares.my-users.basicauth]</span></span><br><span class="line">   users = ["test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/", </span><br><span class="line">            "test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0"]</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># somewhere in a docker compose file</span></span><br><span class="line">your-container:</span><br><span class="line">    image: your-docker-image</span><br><span class="line">    labels:</span><br><span class="line">      - "traefik.http.routers.my-router.middlewares=file.my-users"</span><br></pre></td></tr></table></figure><p>当然，你可以在一个 provider 中声明 router 指向其他 provider 中定义的 services。</p><p><a name="9534f50e"></a></p><h3 id="TLS-Termination-per-Route"><a href="#TLS-Termination-per-Route" class="headerlink" title="TLS Termination per Route"></a>TLS Termination per Route</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1558438336479-c3501663-4a91-48e4-8bf3-9809f9b18d33.png#align=left&display=inline&height=1139&originHeight=1139&originWidth=1600&size=0&status=done&width=1600" alt></p><p>为了添加 TCP 支持到 Traefik 中，我们几乎重新思考了所有事情，从集群的大门-entrypoint 开始。</p><p>我们起初的想法是每个入口点（包括其端口）指定一种类型的协议。不幸的是，在某些情况下，特别是当人们使用Traefik为多个集群路由请求时，我们认为它的限制太大。因此，我们允许每个入口点有多个协议。</p><p>之后，讨论依然存在其他方面，我们一直在寻找让用户在配置TLS termination 或 passthrough 时有更好的控制方式。在路由器级别启用TLS的想法赢得了头脑风暴，然后通过了概念证明的测试(我们团队中有相当多的概念证明分支，以至于它几乎成为了一个迷因)。</p><p>下面是三个路由器监听同一个入口点的例子，第一个 router 完成TLS连接(在HTTPS上)，第二个 router 完成TLS连接(在TCP上)，第三个 router 向后传递，将 TLS连接的细节处理交给服务本身。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[entrypoints]</span></span><br><span class="line">   <span class="section">[entrypoints.web-secure]</span></span><br><span class="line">      address = ":443"</span><br><span class="line"><span class="section">[http]</span></span><br><span class="line">   <span class="section">[http.routers.to-service-1]</span></span><br><span class="line">      rule = "Host(`domain-1`)"</span><br><span class="line">      service = "service-1"</span><br><span class="line">      <span class="section">[http.routers.to-service-1.tls]</span></span><br><span class="line">         <span class="comment"># terminates the tls connection and sends clear data</span></span><br><span class="line">         <span class="comment"># to service 1</span></span><br><span class="line"><span class="section">[tcp]</span></span><br><span class="line">   <span class="section">[tcp.routers.to-service-2]</span></span><br><span class="line">      rule = "HostSNI(`domain-2`)"</span><br><span class="line">      service = "service-2"</span><br><span class="line">      <span class="section">[tcp.routers.to-service-2.tls]</span></span><br><span class="line">         <span class="comment"># terminates the tls connection and sends clear data</span></span><br><span class="line">         <span class="comment"># to service 2</span></span><br><span class="line"><span class="section">[tcp.routers.to-service-3]</span></span><br><span class="line">      rule = "HostSNI(`domain-3`)"</span><br><span class="line">      service = "service-3"</span><br><span class="line">      <span class="section">[tcp.routers.to-service-3.tls]</span></span><br><span class="line">         passthrough = true # sends encrypted data "as is" to service-3</span><br></pre></td></tr></table></figure><p><a name="c5c89dff"></a></p><h3 id="Labels-Key-Value-Configuration-Tags-…"><a href="#Labels-Key-Value-Configuration-Tags-…" class="headerlink" title="Labels, Key-Value Configuration, Tags, …"></a>Labels, Key-Value Configuration, Tags, …</h3><p>这只是表面上的一个小调整，但是对代码有很大的影响，我们重新编写了配置解析器。这个新系统确保 Traefik 中的每个选项都有相同的路径，无论是否用TOML <code>[something.that.is.here]</code>或是容器上的一个 label <code>something.that.is.there</code> ，或是一个键(放在键值存储) <code>something/that/is/somewhere</code>，或者是将来可能可用的任何东西。</p><p><a name="86f46d4d"></a></p><h3 id="修改了文档"><a href="#修改了文档" class="headerlink" title="修改了文档"></a>修改了文档</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1558438336302-918a40dd-2ff1-4012-b80b-48f98832ee60.png#align=left&display=inline&height=931&originHeight=931&originWidth=1600&size=0&status=done&width=1600" alt></p><p>我们更新了文档结构来帮助用户快速的理解如何配置 Traefik。同时，我们列出了配置结构的大纲，让专业用户更方便的学习配置的细节。</p><p><a name="dd289e46"></a></p><h2 id="阅读最终版"><a href="#阅读最终版" class="headerlink" title="阅读最终版"></a>阅读最终版</h2><p>是的，更多的内容还在路上，只是我们（团队）迫不及待去分享了。</p><blockquote><p>新的 WebUI, 剩余的 providers, metrics, UDP, YAML, TLS stores &amp; options, canary（金丝雀）, 更多的文档 — 什么都是有可能的.</p></blockquote><p>除了重新启用其他 providers (alpha只支持 file、Docker和k8s)，并为所有这些 provider 启用TCP(目前只支持 file)之外，路线图还具有很多特性。</p><p>首先，最明显的是，一个贡献者正在积极地开发一个经过改进的WebUI，从我们看到的模型来看，它看起来非常有前途。我们希望这个新UI能够帮助您无缝地浏览数百条路由。</p><p>其次，我们正在对TLS配置进行改进，包括存储和选项，他们应该自解释。</p><p>再次，既然我们已经尝试了一种新的协议，那么我们不妨添加其他协议(如UDP)。</p><p>2.0 文档地址：<a href="https://docs.traefik.io/v2.0/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.traefik.io/v2.0/</a>,大的变更地址：<a href="https://github.com/containous/traefik/blob/master/CHANGELOG.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/containous/traefik/blob/master/CHANGELOG.md</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;traefik 是一个开源的反向代理和负载均衡工具，现在官方介绍中将其定位为云原生的边缘路由器，且用了一堆修饰词：简单、自动、高速、全面、开源、产品级、内置监控指标和主流集群技术集成等等。&lt;br&gt;当然，官方如此描述也是有理有据的，其开源后热度直线上升，而且被广泛使用，尤其是在当下的“微服务”、“云原生”场景。&lt;br&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/328984/1561945084301-b70060bb-6a79-423b-8569-f4c526b6c340.png#align=left&amp;display=inline&amp;height=1501&amp;originHeight=1501&amp;originWidth=2875&amp;size=0&amp;status=done&amp;width=2875&quot; alt&gt;&lt;br&gt;从我个人的角度讲，其相对于传统的反向代理显得更“现代”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态的更新配置，不需要重启/reload等操作。&lt;/li&gt;
&lt;li&gt;原生支持Docker, Swarm mode, Kubernetes, Marathon, Consul, Etcd, Rancher, Amazon ECS等等后端。&lt;/li&gt;
&lt;li&gt;支持 RestAPI&lt;/li&gt;
&lt;li&gt;支持后端健康状态检查，根据状态自动地配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些特点，让其在云原生的场景下更贴合。而traefik本身的特性远不止如此。大家有兴趣可阅读它的官方文档：&lt;a href=&quot;https://docs.traefik.io/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://docs.traefik.io/&lt;/a&gt;，而且国内的资料介绍也很多。&lt;br&gt;本篇文章的背景是因为工作中用到了版本2中的一些特性，但国内关于新版的介绍资料较少，遂对 &lt;a href=&quot;https://blog.containo.us/back-to-traefik-2-0-2f9aa17be305&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;back to traefik 2.0&lt;/a&gt; 这篇文章的核心部分做了简单翻译提取。如有理解错漏，请指正。&lt;/p&gt;
&lt;p&gt;目前（2019年5月21日）2.0 正在开发中，alpha4 版本在 4月17日发布。我们一起看看 2.0 有哪些东西。&lt;/p&gt;
    
    </summary>
    
      <category term="代理" scheme="https://www.ikhan.top/categories/%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="k8s" scheme="https://www.ikhan.top/tags/k8s/"/>
    
      <category term="kubernetes" scheme="https://www.ikhan.top/tags/kubernetes/"/>
    
      <category term="traefik" scheme="https://www.ikhan.top/tags/traefik/"/>
    
  </entry>
  
  <entry>
    <title>快速清除浏览器 DNS 缓存</title>
    <link href="https://www.ikhan.top/posts/flush-chrome-dns.html"/>
    <id>https://www.ikhan.top/posts/flush-chrome-dns.html</id>
    <published>2018-09-01T11:40:03.000Z</published>
    <updated>2019-05-18T11:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发调试的时候经常遇到 host 变更 或者 dns 有变更的情况。但此时我们的浏览器中存在 DNS 缓存和未关闭的 sockets，使 dns 变更无法及时生效。本文推荐 chrome 的小插件可以帮助我们提高效率，免去等待时间。</p><a id="more"></a><p><a name="IO97w"></a></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>chrome 安装插件<a href="https://chrome.google.com/webstore/detail/dns-flusher-for-chrome/okehcbagcgnhifhcppklpmillcdnaclp" rel="external nofollow noopener noreferrer" target="_blank">DNS Flusher for Chrome</a><br><br>或者 <a href="https://chrome.google.com/webstore/detail/flush-dns-close-sockets/mlmlfmdmhdplgecgmiihhfjodokajeel" rel="external nofollow noopener noreferrer" target="_blank">Flush DNS &amp; close sockets</a></p><p><code>DNS Flusher for Chrome</code> 点击清除并且刷新当前页面,或者,在浏览器输入 <code>reload</code> 然后 <code>tab</code> 按键之后再输入网址,就是清除DNS 后访问.</p><p><code>Flush DNS &amp; close sockets</code> 这个插件点击清除,但是不刷新.但是好处是可以用快捷键 <code>ctrl + shrift + f</code> 完成刷新</p><p>这两款插件,都需要指定 <code>--enable-net-benchmarking</code> 的情况下运行 chrome, 如果不知到如何指定请继续往下看</p><p><a name="408f286b"></a></p><h2 id="给-chrome-指定-enable-net-benchmarking-参数运行"><a href="#给-chrome-指定-enable-net-benchmarking-参数运行" class="headerlink" title="给 chrome 指定 --enable-net-benchmarking 参数运行"></a>给 chrome 指定 <code>--enable-net-benchmarking</code> 参数运行</h2><p><a name="d4d53314"></a></p><h3 id="修改快捷方式"><a href="#修改快捷方式" class="headerlink" title="修改快捷方式"></a>修改快捷方式</h3><p>修改 chrome 的快捷方式, 在目标项后面添加<code>--enable-net-benchmarking</code></p><p><img src="https://blog.pic.ikhan.top/20190516100102-flush-dns-chrome-enable-link.png#align=left&display=inline&height=650&originHeight=650&originWidth=419&status=done&width=419" alt></p><p>这样,要求必须通过此快捷方式启动 chrome.</p><p><a name="20403eae"></a></p><h3 id="修改注册表"><a href="#修改注册表" class="headerlink" title="修改注册表"></a>修改注册表</h3><p><code>ctrl + r</code> 运行 <code>regedit</code>,</p><p>找到<code>HKEY_LOCAL_MACHINE–&gt;SOFTWARE–&gt;Classes–&gt;ChromeHTML–&gt;shell–&gt;open–&gt;command</code>对应的配置,在其默认的值中添加 <code>--enable-net-benchmarking</code></p><p><img src="https://blog.pic.ikhan.top/20190516095749-flush-dns-chrome-enable.png#align=left&display=inline&height=520&originHeight=520&originWidth=1085&status=done&width=1085" alt></p><p>这个配置是为了让各种方式启动都能让配置生效</p><p><a name="570326f9"></a></p><h3 id="重启-chrome"><a href="#重启-chrome" class="headerlink" title="重启 chrome"></a>重启 chrome</h3><p>配置后,我们需要关闭原浏览器。注意，如果开启了 google 的桌面通知等后台功能，仅仅是关闭浏览器窗口是无效的，必须完全退出进程才可以，通常检查任务栏通知区域确保无 chrome 图标。进一步可以检查进程管理。如果是锁定到任务栏的 chrome,需要先解除锁定.<br><br>然后我们使用配置了参数的快捷方式运行 chrome.</p><p>运行后,请打开 <code>chrome://version/</code> 页面,确认其中”命令行”一段有 <code>--enable-net-benchmarking</code>,这样就表示配置成功了.</p><p>保证成功后,我们再在任务栏中选择当前浏览器,锁定到任务栏.之前的快捷方式可以选择删除了.</p><p>现在,使用插件测试下吧~</p><p><a name="0d98c747"></a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于 chrome DNS 缓存,可参考另一篇《关于 chrome DNS 缓存》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在开发调试的时候经常遇到 host 变更 或者 dns 有变更的情况。但此时我们的浏览器中存在 DNS 缓存和未关闭的 sockets，使 dns 变更无法及时生效。本文推荐 chrome 的小插件可以帮助我们提高效率，免去等待时间。&lt;/p&gt;
    
    </summary>
    
      <category term="效能,工具" scheme="https://www.ikhan.top/categories/%E6%95%88%E8%83%BD-%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="chrome" scheme="https://www.ikhan.top/tags/chrome/"/>
    
      <category term="dns" scheme="https://www.ikhan.top/tags/dns/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 本地测试环境 MiniKube 介绍及国内安装配置</title>
    <link href="https://www.ikhan.top/posts/minikube-intro-and-install.html"/>
    <id>https://www.ikhan.top/posts/minikube-intro-and-install.html</id>
    <published>2018-05-31T12:59:36.000Z</published>
    <updated>2019-05-21T05:59:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a name="jPKTp"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于初学者来讲，即使有一些教程，从零搭建 Kubernetes 具有一定的门槛。尤其是其中的很多原理概念无法快速掌握，搭建会遇到各种坑，这会非常打击学习者的积极性。好在 Kubernetes 社区提供了可以在本地开发和体验的极简集群实现 MiniKube，对于入门学习来说很方便。本文介绍 Minikube 的简单信息和安装方式。</p><a id="more"></a><p>Minikube 是一个轻量级的 Kubernetes 实现，会在本机创建一台虚拟机，并部署一个只包含一个节点的简单集群。 Minikube 适用于 Linux, Mac OS 和 Windows 系统。Minikube CLI 提供了集群的基本引导操作，包括启动、停止、状态和删除。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/328984/1557804656193-afc59fa1-8823-46ff-b11f-3537384dd532.jpeg#align=left&display=inline&height=768&originHeight=768&originWidth=1024&status=done&width=1024" alt></p><p><a name="73ca6af3"></a></p><h3 id="支持的特性"><a href="#支持的特性" class="headerlink" title="支持的特性"></a>支持的特性</h3><p>目前 Minikube 支持的 kubernetes features 有：</p><ul><li><a href="https://github.com/kubernetes/minikube/blob/master/docs/tunnel.md" rel="external nofollow noopener noreferrer" target="_blank">LoadBalancer</a> - using <code>minikube tunnel</code></li><li>Multi-cluster - using <code>minikube start -p &lt;name&gt;</code></li><li>NodePorts - using <code>minikube service</code></li><li><a href="https://github.com/kubernetes/minikube/blob/master/docs/persistent_volumes.md" rel="external nofollow noopener noreferrer" target="_blank">Persistent Volumes</a></li><li>Ingress</li><li>RBAC</li><li>Dashboard - <code>minikube dashboard</code></li><li><a href="https://github.com/kubernetes/minikube/blob/master/docs/alternative_runtimes.md" rel="external nofollow noopener noreferrer" target="_blank">Container runtimes</a> - <code>start --container-runtime</code></li><li><a href="https://github.com/kubernetes/minikube/blob/master/docs/configuring_kubernetes.md" rel="external nofollow noopener noreferrer" target="_blank">Configure apiserver and kubelet options</a> via command-line flags</li></ul><p>在实际学习体验中，绝大部分的 kubernetes 操作和很多社区工具都是兼容 Minikube 的，可以放心采用 Minikube。</p><p><a name="deefb042"></a></p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><blockquote><p>注：</p><ul><li>更新或切换安装包，需要<ul><li><code>minikube delete</code> 删除现有虚拟机</li><li><code>rm -rf ~/.minikube</code> 删除原本地缓存的文件</li><li>替换新的安装包，重新创建 minikube 环境</li></ul></li><li>本文使用 2019年5月14日 最新的 v1.0.1 版本介绍</li></ul></blockquote><p>先决条件，直接摘录官方 README，其中 <code>kubectl</code> 略作说明，虚拟化支持大家请自行配置。</p><ul><li><a href="https://kubernetes.io/docs/tasks/kubectl/install/" rel="external nofollow noopener noreferrer" target="_blank">kubectl</a></li><li>macOS<ul><li><a href="https://github.com/kubernetes/minikube/blob/master/docs/drivers.md#hyperkit-driver" rel="external nofollow noopener noreferrer" target="_blank">Hyperkit driver</a>, <a href="https://github.com/kubernetes/minikube/blob/master/docs/drivers.md#xhyve-driver" rel="external nofollow noopener noreferrer" target="_blank">xhyve driver</a>, <a href="https://www.virtualbox.org/wiki/Downloads" rel="external nofollow noopener noreferrer" target="_blank">VirtualBox</a>, or <a href="https://www.vmware.com/products/fusion" rel="external nofollow noopener noreferrer" target="_blank">VMware Fusion</a></li></ul></li><li>Linux<ul><li><a href="https://www.virtualbox.org/wiki/Downloads" rel="external nofollow noopener noreferrer" target="_blank">VirtualBox</a> or <a href="https://github.com/kubernetes/minikube/blob/master/docs/drivers.md#kvm-driver" rel="external nofollow noopener noreferrer" target="_blank">KVM</a></li><li><strong>NOTE:</strong> Minikube also supports a <code>--vm-driver=none</code> option that runs the Kubernetes components on the host and not in a VM. Docker is required to use this driver but no hypervisor. If you use <code>--vm-driver=none</code>, be sure to specify a <a href="https://docs.docker.com/network/bridge/#configure-the-default-bridge-network" rel="external nofollow noopener noreferrer" target="_blank">bridge network</a> for docker. Otherwise it might change between network restarts, causing loss of connectivity to your cluster.</li></ul></li><li>Windows<ul><li><a href="https://www.virtualbox.org/wiki/Downloads" rel="external nofollow noopener noreferrer" target="_blank">VirtualBox</a> or <a href="https://github.com/kubernetes/minikube/blob/master/docs/drivers.md#hyperV-driver" rel="external nofollow noopener noreferrer" target="_blank">Hyper-V</a></li></ul></li><li>VT-x/AMD-v virtualization must be enabled in BIOS</li><li>Internet connection on first run</li></ul><p><a name="abdcab2e"></a></p><h2 id="kubectl-安装"><a href="#kubectl-安装" class="headerlink" title="kubectl 安装"></a>kubectl 安装</h2><p>kubectl 安装比较简单，根据系统环境参照<a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>直接选择一种合适的方式即可。 最新版本号就是 kubernetes 版本号，通过 <code>https://storage.googleapis.com/kubernetes-release/release/stable.txt</code> 查看。</p><p>本人 windows 直接选用最新的二进制文件，下载后放入 <code>PATH</code>:</p><p><code>https://storage.googleapis.com/kubernetes-release/release/v1.14.1/bin/windows/amd64/kubectl.exe</code></p><p>如果速度太慢，可以考虑镜像：<code>http://mirror.azure.cn/kubernetes/kubectl/v1.14.1/bin/windows/amd64/kubectl.exe</code></p><p><a name="76dc055a"></a></p><h2 id="安装-Minikube"><a href="#安装-Minikube" class="headerlink" title="安装 Minikube"></a>安装 Minikube</h2><p>重点来了。国内网络原因，免去后面镜像下载等各种麻烦，我们使用阿里修改版的 minikube 安装包(感谢阿里小哥的勤劳）。<br>如果你看这篇文章的时候有更新，和 kubectl 下载地址一样，将地址中版本号修改掉就OK。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.0.1/minikube-windows-amd64.exe</span><br></pre></td></tr></table></figure><p><a name="deb00939"></a></p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>根据如下地址下载，并如 <code>kubectl</code>一样,添加到 <code>PATH</code> 中。</p><p><a name="Windows"></a></p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>从 <a href="http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.27.0/minikube-windows-amd64.exe" rel="external nofollow noopener noreferrer" target="_blank"><code>http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.27.0/minikube-windows-amd64.exe</code></a> 下载并重命名为<code>minikube.exe</code> 。</p><p><a name="852c7e74"></a></p><h4 id="Mac-OSX"><a href="#Mac-OSX" class="headerlink" title="Mac OSX"></a>Mac OSX</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.0.1/minikube-darwin-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p><a name="Linux"></a></p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.0.1/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p><a name="8e54ddfe"></a></p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>缺省Minikube使用VirtualBox驱动来创建Kubernetes本地环境，无代理环境使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start --registry-mirror=https://dockerhub.azk8s.cn</span><br></pre></td></tr></table></figure><p>有代理的话,在命令后面加入代理配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start --registry-mirror=https://dockerhub.azk8s.cn --docker-env HTTP_PROXY=http://proxy_user:proxy_password@proxy_host:proxy_port --docker-env HTTPS_PROXY=https://proxy_user:proxy_password@proxy_host:proxy_port</span><br></pre></td></tr></table></figure><p>如果有私库需要配置 <code>--insecure-registry</code> 的话，也同样直接加在后面。</p><p>如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start --registry-mirror=https://dockerhub.azk8s.cn --insecure-registry docker.examplea.com --insecure-registry docker.exampleb.com</span><br></pre></td></tr></table></figure><p><code>--registry-mirror=</code> 可以配置为你觉得好用的国内 docker 镜像地址。这个可以让你后续下载各种 docker hub 镜像的时候少去很多烦恼。</p><p>启动的过程需要下载搭建集群的镜像和创建虚拟机及相关配置，需要一点时间，适用阿里的 <code>Minikube</code> 应该可以看到速度还是不错的。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1558418332096-2c71d009-f833-4acd-8191-9e8913f6b406.png#align=left&display=inline&height=327&originHeight=327&originWidth=619&size=0&status=done&width=619" alt></p><p>看到成功之后，我们就可以测试一下了。</p><p><a name="925d4871"></a></p><h3 id="测试集群"><a href="#测试集群" class="headerlink" title="测试集群"></a>测试集群</h3><p><code>kubectl version</code> 查看客户端和服务端（kubernetes）集群的版本号，看看 Minikube 给我们安装的是什么版本，目前应该是最新版本 <code>1.14.1</code>,也可以通过 <code>kubectl cluster-info</code> 查看集群的基本信息：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1558418332035-8d70d098-8ae4-47d0-81a5-ab0f4a11d381.png#align=left&display=inline&height=172&originHeight=172&originWidth=1748&size=0&status=done&width=1748" alt></p><p><a name="1174559f"></a></p><h3 id="打开-kubernetes-控制台直观感受下"><a href="#打开-kubernetes-控制台直观感受下" class="headerlink" title="打开 kubernetes 控制台直观感受下"></a>打开 kubernetes 控制台直观感受下</h3><p>kubernetes 官方有配套的 dashboard 项目，可以帮我们直观了解集群运行情况。Minikube 可以很方便帮助我们安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube dashboard</span><br></pre></td></tr></table></figure><p>安装完成后会自动帮我们在浏览器中打开 dashboard。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/328984/1558418332094-24536e6e-abff-466a-bd28-d828b899ce79.png#align=left&display=inline&height=698&originHeight=698&originWidth=1139&size=0&status=done&width=1139" alt></p><p>如果，此处控制台成功启动，就可以说是大功告成，后续的镜像下载（gcr之类镜像的还是要单独配置）什么的基本就不会有问题了。</p><hr><p>本文参考:</p><ul><li><a href="https://yq.aliyun.com/articles/221687" rel="external nofollow noopener noreferrer" target="_blank">Minikube - Kubernetes本地实验环境</a></li><li><a href="https://ehlxr.me/2018/01/12/kubernetes-minikube-installation/" rel="external nofollow noopener noreferrer" target="_blank">Kubernetes 学习笔记之 MiniKube 安装</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a name=&quot;jPKTp&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;对于初学者来讲，即使有一些教程，从零搭建 Kubernetes 具有一定的门槛。尤其是其中的很多原理概念无法快速掌握，搭建会遇到各种坑，这会非常打击学习者的积极性。好在 Kubernetes 社区提供了可以在本地开发和体验的极简集群实现 MiniKube，对于入门学习来说很方便。本文介绍 Minikube 的简单信息和安装方式。&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://www.ikhan.top/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="k8s" scheme="https://www.ikhan.top/tags/k8s/"/>
    
      <category term="kubernetes" scheme="https://www.ikhan.top/tags/kubernetes/"/>
    
      <category term="minikube" scheme="https://www.ikhan.top/tags/minikube/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 Hostname 配置</title>
    <link href="https://www.ikhan.top/posts/centos-7-hostname-config.html"/>
    <id>https://www.ikhan.top/posts/centos-7-hostname-config.html</id>
    <published>2018-05-26T12:11:35.000Z</published>
    <updated>2019-05-28T07:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><a name="8KN3T"></a></p><h2 id="修改Hostname"><a href="#修改Hostname" class="headerlink" title="修改Hostname"></a>修改Hostname</h2><p>之前的 hostname (主机名）修改可以直接通过 <code>hostname</code> 命令临时修改（重启失效），或通过在 <code>/etc/sysconfig/network</code> 文件添加 <code>HOSTNAME=xxx</code> 永久修改等方式。</p><p>centos/redhat 7 中有个 <code>hostnamectl</code> 命令，很好用，使用方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl [--static|--transient|--pretty] <span class="built_in">set</span>-hostname &lt;host-name&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果是需要查看当前系统状态可以用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl [--static|--transient|--pretty] status</span><br></pre></td></tr></table></figure><p>上面两条命令中的可选参数 <code>[--static|--transient|--pretty]</code> 是限定命令是否只针对特定类型的 hostname，不指定的话则是所有。修改后不用重启，立即生效。</p><p>当然，这条命令只会修改主机名，/etc/hosts 中的配置需要自己跟随修改。</p><p><a name="Q6N9e"></a></p><h2 id="关于Hostname类型"><a href="#关于Hostname类型" class="headerlink" title="关于Hostname类型"></a>关于Hostname类型</h2><ul><li>静态的（Static hostname）<br>Static hostname也称为内核主机名，是系统在启动时从/etc/hostname自动初始化的主机名。</li><li>瞬态的（Tansient hostname）<br>Tansient hostname是在系统运行时临时分配的主机名，例如，通过DHCP或mDNS服务器分配。</li><li>灵活的（Pretty hostname）<br>Pretty hostname也有人叫做“别名”主机名。<br>Pretty hostname允许使用自由形式（包括特殊/空白字符）的主机名，以展示给终端用户（如xh01@f5）<br>Static hostname和Pretty hostname都遵从作为互联网域名同样的字符限制规则。</li></ul><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/summer_huan/article/details/76104611" rel="external nofollow noopener noreferrer" target="_blank">CentOS7.0修改主机名(hostname)</a></li><li><a href="https://blog.csdn.net/xuheng8600/article/details/79983927" rel="external nofollow noopener noreferrer" target="_blank">CentOS7修改主机名的三种方法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a name=&quot;8KN3T&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;修改Hostname&quot;&gt;&lt;a href=&quot;#修改Hostname&quot; class=&quot;headerlink&quot; title=&quot;修改Hostname&quot;&gt;&lt;/a&gt;修改Hostname&lt;/h2&gt;&lt;p&gt;之前的 hostname (主机名）修改可以直接通过 &lt;code&gt;hostname&lt;/code&gt; 命令临时修改（重启失效），或通过在 &lt;code&gt;/etc/sysconfig/network&lt;/code&gt; 文件添加 &lt;code&gt;HOSTNAME=xxx&lt;/code&gt; 永久修改等方式。&lt;/p&gt;
&lt;p&gt;centos/redhat 7 中有个 &lt;code&gt;hostnamectl&lt;/code&gt; 命令，很好用，使用方式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hostnamectl [--static|--transient|--pretty] &lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;-hostname &amp;lt;host-name&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="linux" scheme="https://www.ikhan.top/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.ikhan.top/tags/linux/"/>
    
      <category term="centos" scheme="https://www.ikhan.top/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>Docker 宿主机安装配置（K8S前置）</title>
    <link href="https://www.ikhan.top/posts/docker-install-config.html"/>
    <id>https://www.ikhan.top/posts/docker-install-config.html</id>
    <published>2018-05-11T13:39:35.000Z</published>
    <updated>2019-05-30T12:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>不论是单纯的使用 Docker 还是作为 Rancher 、Kubernetes 的前置安装，我们一般都需要做一些配置和处理。此处本文记录共通的一些配置操作，防止遇到问题反复排查。也包括国内加速。基本按顺序处理之后没什么问题。</p><blockquote><p>文中的内容主要是 Centos7 下的操作，其他系统如果有不共通地方，请自行调整。</p></blockquote><a id="more"></a><p><a name="OufCQ"></a></p><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p><a name="OKZn3"></a></p><h3 id="配置-hsotName-和-host-解析"><a href="#配置-hsotName-和-host-解析" class="headerlink" title="配置 hsotName 和 host 解析"></a>配置 hsotName 和 host 解析</h3><p>hostname自己命名即可，但集群中的hostname主机名必须不同！HostName是为了区分不同的主机，防止冲突。云服务商的ECS默认Host的名称一般不会冲突，但是我们最好自己设置下，便于管理。</p><p>Centos7 参考<a href="https://www.ikhan.top/posts/centos-7-hostname-config.html">Centos 7 Hostname 配置</a>，其他系统自行Google。</p><p><a name="kQwPP"></a></p><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><p>在每台主机上执行以下命令关闭防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p><a name="aHDDY"></a></p><h3 id="禁用-SELinux"><a href="#禁用-SELinux" class="headerlink" title="禁用 SELinux"></a>禁用 SELinux</h3><p>如果开启SELinux，很多情况要进行相关的配置，我们这里直接关闭SELinux,减少配置。<br>在每台主机上执行以下命令关闭SELinux。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><p>上面的是临时设置，重启后就无效了。如果需要永久生效，编辑 <code>/etc/selinux/config</code> 文件，修改 <code>SELINUX=disabled</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/^SELINUX=enforcing$/SELINUX=disabled/'</span> /etc/selinux/config</span><br></pre></td></tr></table></figure><p><a name="Cqt9M"></a></p><h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><p>如通不配置，安装K8S会提示：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR FileContent--proc-sys-<span class="built_in">net</span>-bridge-bridge-nf-<span class="keyword">call</span>-iptables]: /proc/sys/<span class="built_in">net</span>/bridge/bridge-nf-<span class="keyword">call</span>-iptables contents are <span class="keyword">not</span> <span class="built_in">set</span> to <span class="number">1</span></span><br></pre></td></tr></table></figure><p>先执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p><a name="0toh8"></a></p><h3 id="关闭-Swap"><a href="#关闭-Swap" class="headerlink" title="关闭 Swap"></a>关闭 Swap</h3><p>使用如下命令关闭 Swap：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a &amp;&amp; sed -i <span class="string">'/swap/d'</span> /etc/fstab</span><br></pre></td></tr></table></figure><p>前面关闭当前，后面永久关闭。<br>否则在当前机器上安装Kubernetes会提示：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR Swap]: <span class="built_in">running</span> <span class="keyword">with</span> swap <span class="keyword">on</span> <span class="keyword">is</span> <span class="keyword">not</span> supported. Please disable swap</span><br></pre></td></tr></table></figure><p><a name="ELpsI"></a></p><h2 id="删除老版本"><a href="#删除老版本" class="headerlink" title="删除老版本"></a>删除老版本</h2><p>如果机器已经存在老版本Docker，用如下命令删除（不确定也可直接执行）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><p><a name="msDoa"></a></p><h2 id="通过仓库安装新版"><a href="#通过仓库安装新版" class="headerlink" title="通过仓库安装新版"></a>通过仓库安装新版</h2><p><a name="MfqDD"></a></p><h3 id="配置仓库"><a href="#配置仓库" class="headerlink" title="配置仓库"></a>配置仓库</h3><ol><li>安装依赖包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><ol start="2"><li>配置阿里加速仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo &amp;&amp; \</span><br><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure><ol start="3"><li>配置官方 <code>stable</code> 仓库（和上面二选一）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo  &amp;&amp; \</span><br><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure><p><a name="7421310f"></a></p><h3 id="安装-DOCKER-CE"><a href="#安装-DOCKER-CE" class="headerlink" title="安装 DOCKER CE"></a>安装 DOCKER CE</h3><p><a name="88574b9e"></a></p><h4 id="安装最新版"><a href="#安装最新版" class="headerlink" title="安装最新版"></a>安装最新版</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p><a name="cbc8c47c"></a></p><h4 id="安装指定版本"><a href="#安装指定版本" class="headerlink" title="安装指定版本"></a>安装指定版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="comment"># 选择安装</span></span><br><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br><span class="line"><span class="comment">#Install a specific version by its fully qualified package name, which is the package name (docker-ce) plus the version string (2nd column) starting at the first colon (:), up to the first hyphen, separated by a hyphen (-). For example, docker-ce-18.09.1</span></span><br></pre></td></tr></table></figure><p><a name="9c7f82a1"></a></p><h3 id="启动-docker"><a href="#启动-docker" class="headerlink" title="启动 docker"></a>启动 docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p><a name="XoF6v"></a></p><h2 id="安装后基本配置"><a href="#安装后基本配置" class="headerlink" title="安装后基本配置"></a>安装后基本配置</h2><p><a name="sUnXX"></a></p><h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">vim /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line"><span class="comment">## 添加如下配置</span></span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://user:password@192.168.x.x:port"</span> <span class="string">"HTTPS_PROXY=http://user:password@192.168.x.x:port"</span> <span class="string">"NO_PROXY=localhost,127.0.0.1"</span></span><br></pre></td></tr></table></figure><p><a name="mKPep"></a></p><h3 id="私库-–insecure-registry"><a href="#私库-–insecure-registry" class="headerlink" title="私库 –insecure-registry"></a>私库 –insecure-registry</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br><span class="line"><span class="comment"># 将  ExecStart=/usr/bin/dockerd 参数后添加 --insecure-registry 配置，示例如下</span></span><br><span class="line">ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry=docker.foo.com --insecure-registry=docker.bar.com</span><br></pre></td></tr></table></figure><p><a name="memke"></a></p><h3 id="国内加速"><a href="#国内加速" class="headerlink" title="国内加速"></a>国内加速</h3><p>关于镜像加速包括 gcr.io、quay.io 建议看文章：<a href="https://www.ikhan.top/posts/docker-mirrors.html">Docker 国内镜像加速</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://dockerhub.azk8s.cn"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p><a name="9ZdGU"></a></p><h3 id="修改Docker-Cgroup-Driver"><a href="#修改Docker-Cgroup-Driver" class="headerlink" title="修改Docker Cgroup Driver"></a>修改Docker Cgroup Driver</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"exec-opts"</span>: [<span class="string">"native.cgroupdriver=systemd"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="xrJKI"></a></p><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><p><a name="MXhiC"></a></p><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p><a name="I4jAO"></a></p><h3 id="清除机器上容器"><a href="#清除机器上容器" class="headerlink" title="清除机器上容器"></a>清除机器上容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -aq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker container prune   # Remove all stopped containers</span></span><br><span class="line"><span class="comment"># docker volume prune      # Remove all unused volumes</span></span><br><span class="line"><span class="comment"># docker image prune       # Remove unused images</span></span><br><span class="line"><span class="comment"># docker system prune      # All of the above, in this order: containers, volumes, images</span></span><br><span class="line"><span class="built_in">echo</span> y | docker system prune</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不论是单纯的使用 Docker 还是作为 Rancher 、Kubernetes 的前置安装，我们一般都需要做一些配置和处理。此处本文记录共通的一些配置操作，防止遇到问题反复排查。也包括国内加速。基本按顺序处理之后没什么问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文中的内容主要是 Centos7 下的操作，其他系统如果有不共通地方，请自行调整。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="容器" scheme="https://www.ikhan.top/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="docker" scheme="https://www.ikhan.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 国内镜像加速</title>
    <link href="https://www.ikhan.top/posts/docker-mirrors.html"/>
    <id>https://www.ikhan.top/posts/docker-mirrors.html</id>
    <published>2018-05-11T12:16:39.000Z</published>
    <updated>2019-05-30T12:39:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于网络原因，国内直接从 docker hub、gcr.io 和 quay.io 下载镜像并不顺畅。通过镜像加速（mirrors）是必须的了。本文介绍国内常见的镜像加速站，并以我常用的 Azure 为例介绍具体配置。</p><a id="more"></a><p><a name="mlRxH"></a></p><h2 id="Azure-加速器使用"><a href="#Azure-加速器使用" class="headerlink" title="Azure 加速器使用"></a>Azure 加速器使用</h2><p>国内目前可用的加速器有很多，Azure 是我使用下来较为全面和稳定的，阿里云的我也常用，但是需要注册且不包含gcr和quay的mirror统一入口。如果你已经有阿里云的加速器地址，可以DockerHub官方镜像使用阿里云配置，gcr和quay另选。更多的加速器在后面提供，大家可以根据情况自由选择。<br>Azure 不仅有镜像加速，还有其他的安装包等加速，官方：<a href="http://mirror.azure.cn/" rel="external nofollow noopener noreferrer" target="_blank">http://mirror.azure.cn/</a></p><p><a name="3AdbK"></a></p><h3 id="DockerHub官方镜像"><a href="#DockerHub官方镜像" class="headerlink" title="DockerHub官方镜像"></a>DockerHub官方镜像</h3><p>DockerHub 的官方镜像可以通过配置 <code>/etc/docker/daemon.json</code> 的 <code>registry-mirrors</code> ，然后正常使用即可，拉取（pull）镜像的地址并不用更改。非DockerHub官方的镜像，无法通过此方式获得加速，必须用修改镜像地址为加速器专用地址的方式进行。修改方式后面根据情况会分别讲述。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://dockerhub.azk8s.cn"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p><code>registry-mirrors</code> 可配置多个镜像加速器，我用阿里云和Azure基本可达到近8-10M/s，也很稳定。多个镜像加速器是否会有很大的速度或稳定性提升没有严格测试过，我配置两个用的话小镜像略有影响，所以还是配一个。如果你有测试结论，请告诉我。</p><p><a name="caznb"></a></p><h3 id="gcr-io-镜像"><a href="#gcr-io-镜像" class="headerlink" title="gcr.io 镜像"></a>gcr.io 镜像</h3><p>对于非 k8s.gcr.io 的gcr.io镜像，一般将域名修改为加速器地址，仓库地址不变即可。<br>比如，原来要拉取的镜像是 <code>gcr.io/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;version&gt;</code> 形式，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull gcr.io/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;version&gt;</span><br></pre></td></tr></table></figure><p>使用Azure加速修改后的地址是 <code>gcr.azk8s.cn/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;version&gt;</code> ，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull gcr.azk8s.cn/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;version&gt;</span><br></pre></td></tr></table></figure><p><a name="9Yidz"></a></p><h4 id="重新tag镜像，和原始镜像保持一致"><a href="#重新tag镜像，和原始镜像保持一致" class="headerlink" title="重新tag镜像，和原始镜像保持一致"></a>重新tag镜像，和原始镜像保持一致</h4><p>当然，下载后的镜像tag和原tag自然不同，如果需要按照原tag使用，执行如下命令重新tag就OK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag gcr.azk8s.cn/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;version&gt; gcr.io/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;version&gt;</span><br></pre></td></tr></table></figure><p>如果tag后不希望 images 里保留过多tag，可以删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi gcr.azk8s.cn/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;version&gt;</span><br></pre></td></tr></table></figure><p>其他的加速方式一致</p><p><a name="Q2VVK"></a></p><h3 id="k8s-gcr-io-镜像"><a href="#k8s-gcr-io-镜像" class="headerlink" title="k8s.gcr.io 镜像"></a>k8s.gcr.io 镜像</h3><p>k8s.gcr.io 下的镜像被映射到加速器的 <code>google_containers</code>  仓库，<br>      即原： <code>k8s.gcr.io/&lt;image-name&gt;:&lt;version&gt;</code> <br>被映射为： <code>gcr.azk8s.cn/google_containers/&lt;image-name&gt;:&lt;version&gt;</code> 。<br>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k8s.gcr.io/pause-amd64:3.1</span><br><span class="line">gcr.azk8s.cn/google_containers/pause-amd64:3.1</span><br></pre></td></tr></table></figure><p><a name="qBlCy"></a></p><h3 id="quay-io-镜像"><a href="#quay-io-镜像" class="headerlink" title="quay.io 镜像"></a>quay.io 镜像</h3><p>quay.io 和 gcr.io一致，<br>      原： <code>quay.io/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;version&gt;</code> <br>修改后： <code>quay.azk8s.cn/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;version&gt;</code> </p><p><a name="h46sQ"></a></p><h2 id="加速器列表"><a href="#加速器列表" class="headerlink" title="加速器列表"></a>加速器列表</h2><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th><th>专属加速器<a href="#">？</a></th><th>其它加速<a href="#">？</a></th></tr></thead><tbody><tr><td><a href="https://docker-cn.com/registry-mirror" rel="external nofollow noopener noreferrer" target="_blank">Docker 中国官方镜像</a></td><td><code>https://registry.docker-cn.com</code></td><td></td><td>Docker Hub</td></tr><tr><td><a href="https://daocloud.io/mirror" rel="external nofollow noopener noreferrer" target="_blank">DaoCloud 镜像站</a></td><td><code>http://&lt;your_code&gt;.m.daocloud.io</code></td><td>可登录，系统分配</td><td>Docker Hub</td></tr><tr><td><a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" rel="external nofollow noopener noreferrer" target="_blank">Azure 中国镜像</a></td><td><code>https://dockerhub.azk8s.cn</code></td><td></td><td>Docker Hub、GCR、Quay</td></tr><tr><td><a href="https://mirrors.ustc.edu.cn/help/dockerhub.html" rel="external nofollow noopener noreferrer" target="_blank">科大镜像站</a></td><td><code>https://docker.mirrors.ustc.edu.cn</code></td><td></td><td>Docker Hub、<a href="https://github.com/ustclug/mirrorrequest/issues/91" rel="external nofollow noopener noreferrer" target="_blank">GCR</a>、<a href="https://github.com/ustclug/mirrorrequest/issues/135" rel="external nofollow noopener noreferrer" target="_blank">Quay</a></td></tr><tr><td><a href="https://cr.console.aliyun.com" rel="external nofollow noopener noreferrer" target="_blank">阿里云</a></td><td><code>https://&lt;your_code&gt;.mirror.aliyuncs.com</code></td><td>需登录，系统分配</td><td>Docker Hub</td></tr><tr><td><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" rel="external nofollow noopener noreferrer" target="_blank">七牛云</a></td><td><code>https://reg-mirror.qiniu.com</code></td><td></td><td>Docker Hub、GCR、Quay</td></tr><tr><td><a href="https://c.163yun.com/hub" rel="external nofollow noopener noreferrer" target="_blank">网易云</a></td><td><code>https://hub-mirror.c.163.com</code></td><td></td><td>Docker Hub</td></tr><tr><td><a href="https://cloud.tencent.com/document/product/457/9113" rel="external nofollow noopener noreferrer" target="_blank">腾讯云</a></td><td><code>https://mirror.ccs.tencentyun.com</code></td><td></td><td>Docker Hub</td></tr></tbody></table><p><a name="DTvJl"></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://yisi14.com/post/6557" rel="external nofollow noopener noreferrer" target="_blank">Docker Hub 镜像加速器</a></li><li><a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" rel="external nofollow noopener noreferrer" target="_blank">container-service-for-azure-china</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于网络原因，国内直接从 docker hub、gcr.io 和 quay.io 下载镜像并不顺畅。通过镜像加速（mirrors）是必须的了。本文介绍国内常见的镜像加速站，并以我常用的 Azure 为例介绍具体配置。&lt;/p&gt;
    
    </summary>
    
      <category term="容器" scheme="https://www.ikhan.top/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="docker" scheme="https://www.ikhan.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>【转】微服务（Microservices）- Martin Fowler文章翻译</title>
    <link href="https://www.ikhan.top/posts/microservices-translation.html"/>
    <id>https://www.ikhan.top/posts/microservices-translation.html</id>
    <published>2017-11-26T12:18:06.000Z</published>
    <updated>2019-07-18T07:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>微服务的文章，还是以Martin Fowler的<a href="https://martinfowler.com/articles/microservices.html" rel="external nofollow noopener noreferrer" target="_blank">Microservices</a>一文为经典。国内已经有很多翻译。本文转载了ThoughtWorks 伍斌的翻译，可能会有少量的语言调整。</p><a id="more"></a><p>“微服务架构”这一术语在前几年横空出世，用于描述这样一种特定的软件设计方法，即以若干组可独立部署的服务的方式进行软件应用系统的设计。尽管这种架构风格尚无明确的定义，但其在下述方面还是存在一定的共性，即围绕业务功能的组织、自动化部署、端点智能、以及在编程语言和数据方面进行去中心化的控制。<br><a name="Wvzwd"></a></p><h3 id="本文目录"><a href="#本文目录" class="headerlink" title="本文目录"></a>本文目录</h3><ul><li>微服务架构的九大特性<ul><li>特性一：“组件化”与“多服务”</li><li>特性二：围绕“业务功能”组织团队</li><li>特性三：“做产品”而不是“做项目”</li><li>特性四：“智能端点”与“傻瓜管道”</li><li>特性五：“去中心化”地治理技术</li><li>特性六：“去中心化”地管理数据</li><li>特性七：“基础设施”自动化</li><li>特性八：“容错”设计</li><li>特性九：“演进式”设计</li></ul></li><li>未来的方向是“微服务”吗？<br></li></ul><hr><p>“微服务”——这是在“软件架构”这条熙熙攘攘的大街上出现的又一个新词语。我们很容易对它不屑一顾，但是这个小小的术语却描述了一种引人入胜的软件系统风格。在近几年中，我们越来越多的看到许多项目使用了这种风格，而且就目前来说结果都是不错的，以至于许多ThoughtWorker都把它看作构建企业应用系统的默认风格。然而，很不幸的是，我们找不到有关它的概要信息，即什么是微服务风格，以及如何设计微服务风格的架构。<br>简而言之，微服务架构风格[1]这种开发方法，是以开发一组小型服务的方式来开发一个独立的应用系统。其中每个小型服务都运行在自己的进程中，并经常采用HTTP资源API这样轻量的机制来相互通信。这些服务围绕业务功能进行构建，并能通过全自动的部署机制来进行独立部署。这些微服务可以使用不同的语言来编写，并且可以使用不同的数据存储技术。对这些微服务，我们仅做最低限度的集中管理。<br>在开始介绍微服务风格之前，将其与单块（monolithic）风格进行对比还是很有意义的：一个单块应用系统是以一个单个单元的方式来构建的。企业应用系统经常包含三个主要部分：客户端用户界面、数据库和服务端应用系统。客户端用户界面包括HTML页面和运行在用户机器的浏览器中的JavaScript。数据库中包括许多表，这些表被插入一个公共的且通常为关系型的数据库管理系统中。这个服务端的应用系统就是一个单块应用——一个单个可执行的逻辑程序[2]。对于该系统的任何改变，都会涉及构建和部署上述服务端应用系统的一个新版本。<br>这样的单块服务器是构建上述系统的一种自然的方式。处理用户请求的所有逻辑都运行在一个单个的进程内，因此能使用编程语言的基本特性，来把应用系统划分为类、函数和命名空间。通过精心设计，得以在开发人员的笔记本电脑上运行和测试这样的应用系统，并且使用一个部署流水线来确保变更被很好地进行了测试，并被部署到生产环境中。通过负载均衡器运行许多实例，来将这个单块应用进行横向扩展。<br>单块应用系统可以被成功地实现，但是渐渐地，特别是随着越来越多的应用系统正被部署到云端，人们对它们开始表现出不满。软件变更受到了很大的限制，应用系统中一个很小部分的一处变更，也需要将整个单块应用系统进行重新构建和部署。随着时间的推移，单块应用逐渐难以保持一个良好的模块化结构，这使得它变得越来越难以将一个模块的变更所产生的影响控制在该模块内。当对系统进行扩展时，不得不扩展整个应用系统，而不能仅扩展该系统中需要更多资源的那些部分。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/webp/328984/1563434196029-d93187d4-3c81-4af9-972a-34ffaecbc63f.webp#align=left&display=inline&height=612&originHeight=612&originWidth=1000&size=0&status=done&width=1000" alt></p><p>图1: 单块应用和微服务<br>这些不满催生出了微服务架构风格：以构建一组小型服务的方式来构建应用系统。除了这些服务能被独立地部署和扩展之外，每一个服务还能提供一个稳固的模块边界，甚至能允许使用不同的编程语言来编写不同的服务。这些服务也能被不同的团队来管理。<br>我们并不认为微服务风格是一个新颖或创新的概念，它的起源至少可以追溯到Unix的设计原则。但是我们觉得，考虑微服务架构的人还不够多，并且如果对其加以使用，许多软件的开发工作能变得更好。<br><a name="3nRiR"></a></p><h3 id="微服务架构的九大特性"><a href="#微服务架构的九大特性" class="headerlink" title="微服务架构的九大特性"></a>微服务架构的九大特性</h3><p>虽然不能说存在微服务架构风格的正式定义，但是可以尝试描述我们所见到的、能够被贴上“微服务”标签的那些架构的共性。下面所描述的这些共性，并不是所有的微服务架构都完全具备，但是我们确实期望大多数微服务架构都具备这些共性中的大多数特性。尽管我们两位作者已经成为这个相当松散的社区中的活跃成员，但我们的本意还是描述我们两人在自己所在和所了解的团队工作中所看到的情况。特别要指出，我们不会制定大家需要遵循的微服务的定义。<br><a name="lTKyF"></a></p><h4 id="特性一：“组件化”与“多服务”"><a href="#特性一：“组件化”与“多服务”" class="headerlink" title="特性一：“组件化”与“多服务”"></a>特性一：“组件化”与“多服务”</h4><p>自我们从事软件行业以来，发现大家都有“把组件插在一起来构建系统”的愿望，就像在物理世界中所看到的那样。在过去几十年中，我们已经看到，在公共软件库方面已经取得了相当大的进展，这些软件库是大多数编程语言平台的组成部分。<br>当谈到组件时，会碰到一个有关定义的难题，即什么是组件？我们的定义是：一个组件就是一个可以独立更换和升级的软件单元。<br>微服务架构也会使用软件库，但其将自身软件进行组件化的主要方法是将软件分解为诸多服务。我们将软件库(libraries)定义为这样的组件，即它能被链接到一段程序，且能通过内存中的函数来进行调用。然而，服务(services)是进程外的组件，它们通过诸如web service请求或远程过程调用这样的机制来进行通信（这不同于许多面向对象的程序中的service object概念[3]）。<br>以使用服务（而不是以软件库）的方式来实现组件化的一个主要原因是，服务可被独立部署。如果一个应用系统[4]由在单个进程中的多个软件库所组成，那么对任一组件做一处修改，都不得不重新部署整个应用系统。但是如果该应用系统被分解为多个服务，那么对于一个服务的多处修改，仅需要重新部署这一个服务。当然这也不是绝对的，一些变更服务接口的修改会导致多个服务之间的协同修改。但是一个良好的微服务架构的目的，是通过内聚的服务边界和服务协议方面的演进机制，来将这样的修改变得最小化。<br>以服务的方式来实现组件化的另一个结果，是能获得更加显式的（explicit）组件接口。大多数编程语言并没有一个良好的机制来定义显式的<a href="https://link.jianshu.com?t=https://martinfowler.com/bliki/PublishedInterface.html" rel="external nofollow noopener noreferrer" target="_blank">发布接口</a>。通常情况下，这样的接口仅仅是文档声明和团队纪律，来避免客户端破坏组件的封装，从而导致组件间出现过度紧密的耦合。通过使用显式的远程调用机制，服务能更容易地规避这种情况。<br>如此使用服务，也会有不足之处。比起进程内调用，远程调用更加昂贵。所以远程调用API接口必须是粗粒度的，而这往往更加难以使用。如果需要修改组件间的职责分配，那么当跨越进程边界时，这种组件行为的改动会更加难以实现。<br>近似地，我们可以把一个个服务映射为一个个运行时的进程，但这仅仅是一个近似。一个服务可能包括总是在一起被开发和部署的多个进程，比如一个应用系统的进程和仅被该服务使用的数据库。<br><a name="m8Vg6"></a></p><h4 id="特性二：围绕“业务功能”组织团队"><a href="#特性二：围绕“业务功能”组织团队" class="headerlink" title="特性二：围绕“业务功能”组织团队"></a>特性二：围绕“业务功能”组织团队</h4><p>当在寻求将一个大型应用系统分解成几部分时，公司管理层往往会聚焦在技术层面上，这就意味着要组建用户界面团队、服务器端团队和数据库团队。当团队沿着这些技术线分开后，即使要实现软件中一个简单的变更，也会发生跨团队的项目时延和预算审批。在这种情况下，聪明的团队会进行局部优化，“两害相权取其轻”，来直接把代码逻辑塞到他们能访问到的任意应用系统中。换句话说，这种情况会导致代码逻辑散布在系统各处。这就是康威定律[5]的鲜活实例。</p><blockquote><p>任何设计（广义上的）系统的组织，都会产生这样一个设计，即该设计的结构与该组织的沟通结构相一致。——梅尔文•康威（Melvyn Conway）, 1967年</p></blockquote><p><br><img src="https://cdn.nlark.com/yuque/0/2019/webp/328984/1563434196021-20f9584c-0ada-48fc-91f0-7054f8239338.webp#align=left&display=inline&height=735&originHeight=735&originWidth=940&size=0&status=done&width=940" alt></p><p>图2：康威定律在起作用<br>微服务使用不同的方法来分解系统，即根据业务功能（business capability）来将系统分解为若干服务。这些服务针对该业务领域提供多层次、广泛的软件实现，包括用户界面、持久性存储以及任何对外的协作性操作。因此，团队是跨职能的，它拥有软件开发所需的全方位的技能：用户体验、数据库和项目管理。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/webp/328984/1563434196013-212b5879-290b-43d2-9b86-04b4054950bb.webp#align=left&display=inline&height=566&originHeight=566&originWidth=1000&size=0&status=done&width=1000" alt></p><p>图3：被团队边界所强化的服务边界<br>以上述方式来组织团队的公司是<a href="https://link.jianshu.com?t=www.comparethemarket.com" rel="external nofollow noopener noreferrer" target="_blank">www.comparethemarket.com</a>。跨职能团队负责构建和运维每个产品，而每个产品被拆分为多个独立的服务，彼此通过一个消息总线来通信。</p><blockquote><p><strong>一个微服务应该有多大？</strong><br>尽管许多人已经习惯于用“微服务”来概括描述这种这种架构风格，但是这个名字确实会不幸地引发大家对服务规模的关注，并且产生有关什么是“微”的争论。在与微服务从业者的交谈中，我们看到了有关服务的一系列规模。所听到的最大的一个服务规模，是遵循了亚马逊的“两个比萨团队”（即一个团队可以被两个比萨所喂饱）的理念所形成的，这意味着这个团队不会多于12人。对于规模较小的服务，我们已经看到一个6人的团队在支持6个服务。<br>这引出了一个问题，即“每12人做一个服务”和“每人做一个服务”这样有关服务规模的差距，是否已经大到不能将两者都纳入微服务之下？此时，我们认为最好还是把它们归为一类，但是随着探索的深入，我们将来极有可能会改变主意。</p></blockquote><p>大型单块应用系统也可以始终根据业务功能来进行模块化设计，虽然这并不常见。当然，我们会敦促构建单块应用系统的大型团队根据业务线来将自己分解为若干小团队。在这方面，我们已经看到的主要问题是，他们往往是一个团队包含了太多的业务功能。如果这个“单块”跨越了许多模块的边界，那么这个团队的每一个成员都难以记住所有模块的业务功能。此外，我们看到这些模块的边界需要大量的团队纪律来强制维持。而实现组件化的服务所必要的更加显式的边界，能更加容易地保持团队边界的清晰性。<br><a name="2nYNb"></a></p><h4 id="特性三：“做产品”而不是“做项目”"><a href="#特性三：“做产品”而不是“做项目”" class="headerlink" title="特性三：“做产品”而不是“做项目”"></a>特性三：“做产品”而不是“做项目”</h4><p>我们所看的大部分应用系统的开发工作都使用项目模型：目标是交付某一块软件，之后就认为完工了。一旦完工后，软件就被移交给维护团队，接着那个构建该软件的项目团队就会被解散。<br>微服务的支持者们倾向于避免使用上述模型，而宁愿采纳“一个团队在一个产品的整个生命周期中都应该保持对其拥有”的理念。通常认为这一点源自亚马逊的“<a href="https://link.jianshu.com?t=https://queue.acm.org/detail.cfm?id=1142065" rel="external nofollow noopener noreferrer" target="_blank">谁构建，谁运行</a>”的理念，即一个开发团队对一个在生产环境下运行的软件负全责。这会使开发人员每天都关注软件是如何在生产环境下运行的，并且增进他们与用户的联系，因为他们必须承担某些支持工作。<br>这样的“产品”理念，是与业务功能的联动绑定在一起的。它不会将软件看作是一个待完成的功能集合，而是认为存在这样一个持续的关系，即软件如何能助其客户来持续增进业务功能。<br>当然，单块应用系统的开发工作也可以遵循上述“产品”理念，但是更细粒度的服务，能让服务的开发者与其用户之间的个人关系的创建变得更加容易。<br><a name="HDmRV"></a></p><h4 id="特性四：“智能端点”与“傻瓜管道”"><a href="#特性四：“智能端点”与“傻瓜管道”" class="headerlink" title="特性四：“智能端点”与“傻瓜管道”"></a>特性四：“智能端点”与“傻瓜管道”</h4><p>当在不同的进程之间构建各种通信结构时，我们已经看到许多产品和方法，来强调将大量的智能特性纳入通信机制本身。其中一个典型例子，就是“企业服务总线”(Enterprise Service Bus, ESB)。ESB产品经常包括高度智能的设施，来进行消息的路由、编制(choreography)、转换，并应用业务规则。<br>微服务社区主张采用另一种做法：智能端点(smart endpoints)和傻瓜管道(dumb pipes)。使用微服务所构建的各个应用的目标，都是尽可能地实现“高内聚和低耦合”——他们拥有自己的领域逻辑，并且更像是经典Unix的“过滤器”(filter)那样来工作——即接收一个请求，酌情对其应用业务逻辑，并产生一个响应。这些应用通过使用一些简单的REST风格的协议来进行编制，而不去使用诸如下面这些复杂的协议，即”WS-编制”(WS-Choreography)、BPEL或通过位于中心的工具来进行编排(orchestration)。<br>微服务最常用的两种协议是：带有资源API的HTTP“请求－响应”协议，和轻量级的消息发送协议[6]。对于前一种协议的最佳表述是：</p><blockquote><p>成为Web，而不是躲着Web (Be of the web, not behind the web)——Ian Robinson</p></blockquote><p>这些微服务团队在开发中，使用在构建万维网(world wide web)时所使用的原则和协议（并且在很大程度上，这些原则和协议也是在构建Unix系统时所使用的）。那些被使用过的HTTP资源，通常能被开发或运维人员轻易地缓存起来。<br>最常用的第二种协议，是通过一个轻量级的消息总线来进行消息发送。此时所选择的基础设施，通常是“傻瓜”(dumb)型的(仅仅像消息路由器所做的事情那样傻瓜)——像RabbitMQ或ZeroMQ那样的简单实现，即除了提供可靠的异步机制(fabric)以外不做其他任何事情——智能功能存在于那些生产和消费诸多消息的各个端点中，即存在于各个服务中。<br>在一个单块系统中，各个组件在同一个进程中运行。它们相互之间的通信，要么通过方法调用，要么通过函数调用来进行。将一个单块系统改造为若干微服务的最大问题，在于对通信模式的改变。仅仅将内存中的方法调用转换为RPC调用这样天真的做法，会导致微服务之间产生繁琐的通信，使得系统表现变糟。取而代之的是，需要用更粗粒度的协议来替代细粒度的服务间通信。<br><a name="Lcpn5"></a></p><h4 id="特性五：“去中心化”的治理技术"><a href="#特性五：“去中心化”的治理技术" class="headerlink" title="特性五：“去中心化”的治理技术"></a>特性五：“去中心化”的治理技术</h4><p>使用中心化的方式来对开发进行治理，其中一个后果，就是趋向于在单一技术平台上制定标准。经验表明，这种做法会带来局限性——不是每一个问题都是钉子，不是每一个方案都是锤子。我们更喜欢根据工作的不同来选用合理的工具。尽管那些单块应用系统能在一定程度上利用不同的编程语言，但是这并不常见。<br>如果能将单块应用的那些组件拆分成多个服务，那么在构建每个服务时，就可以有选择不同技术栈的机会。想要使用Node.js来搞出一个简单的报表页面？尽管去搞。想用C++来做一个特别出彩的近乎实时的组件？没有问题。想要换一种不同风格的数据库，来更好地适应一个组件的读取数据的行为？可以重建。</p><blockquote><p><strong>微服务和SOA</strong><br>当我们谈起微服务时，一个常见的问题就会出现：是否微服务仅仅是十多年前所看到的“面向服务的架构”(Service Oriented Architecture, SOA)？这样问是有道理的，因为微服务风格非常类似于一些支持SOA的人所赞成的观点。然而，问题在于<a href="https://link.jianshu.com?t=https://martinfowler.com/bliki/ServiceOrientedAmbiguity.html" rel="external nofollow noopener noreferrer" target="_blank">SOA这个词儿意味着太多不同的东西</a>。而且大多数时候，我们所遇到的某些被称作”SOA”的事物，明显不同于本文所描述的风格。这通常由于它们专注于ESB，来集成各个单块应用。<br>特别地，我们已经看到如此之多的面向服务的拙劣实现——从将系统复杂性隐藏于ESB中的趋势[7]，到花费数百万进行多年却没有交付任何价值的失败项目，到顽固抑制变化发生的中心化技术治理模型——以至于有时觉得其所造成的种种问题真的不堪回首。<br>当然，在微服务社区投入使用的许多技术，源自各个开发人员将各种服务集成到各个大型组织的经验。“<a href="https://link.jianshu.com?t=https://martinfowler.com/bliki/TolerantReader.html" rel="external nofollow noopener noreferrer" target="_blank">容错读取</a>”(Tolerant Reader)模式就是这样一个例子。对于Web的广泛使用，使得人们不再使用一些中心化的标准，而使用一些简单的协议。坦率地说，这些中心化的标准，其复杂性已经达到令人吃惊的程度。（任何时候，如果需要一个本体来管理其他各个本体，那么麻烦就大了。）<br>这种常见的SOA表现，已使得一些微服务的倡导者完全拒绝将自己贴上SOA的标签。尽管其他人会将微服务看作是SOA的一种形式[8]，也许微服务就是以正确的形式来实现面向服务的SOA。不管是哪种情况，SOA意味着如此之多的不同事物，这表明用一个更加干净利落的术语来命名这种架构风格是很有价值的。</p></blockquote><p>当然，仅仅能做事情，并不意味着这些事情就应该被做——不过用微服务的方法把系统进行拆分后，就拥有了技术选型的机会。<br>相比选用业界一般常用的技术，构建微服务的那些团队更喜欢采用不同的方法。与其选用一组写在纸上已经定义好的标准，他们更喜欢编写一些有用的工具，来让其他开发者能够使用，以便解决那些和他们所面临的问题相似的问题。这些工具通常源自他们的微服务实施过程，并且被分享到更大规模的组织中，这种分享有时会使用内部开源的模式来进行。事实上，现在git和github已经成为首选版本控制系统。在企业内部，开源的做法正在变得越来越普遍。<br>Netflix公司是遵循上述理念的好例子。将实用且经过实战检验的代码以软件库的形式共享出来，能鼓励其他开发人员以相似的方式来解决相似的问题，当然也为在需要的时候选用不同的方案留了一扇门。共享软件库往往聚焦于解决这样的常见问题，即数据存储、进程间的通信和下面要进一步讨论的基础设施的自动化。<br>对于微服务社区来说，日常管理开销这一点不是特别吸引人。这并不是说这个社区并不重视服务契约。恰恰相反，它们在社区里出现得更多。这正说明这个社区正在寻找对其进行管理的各种方法。像“容错读取”和“<a href="https://link.jianshu.com?t=https://martinfowler.com/articles/consumerDrivenContracts.html" rel="external nofollow noopener noreferrer" target="_blank">消费者驱动的契约</a>”(Consumer-Driven Contracts)这样的模式，经常被运用到微服务中。这些都有助于服务契约进行独立演进。将执行“消费者驱动的契约”做为软件构建的一部分，能增强开发团队的信心，并提供所依赖的服务是否正常工作的快速反馈。实际上，我们了解到一个在澳洲的团队就是使用“消费者驱动的契约”来驱动构建多个新服务的。他们使用了一些简单的工具，来针对每一个服务定义契约。甚至在新服务的代码编写之前，这件事就已经成为自动化构建的一部分了。接下来服务仅被构建到刚好能满足契约的程度——这是一个在构建新软件时避免YAGNI[9]困境的优雅方法。这些技术和工具在契约周边生长出来，由于减少了服务之间在时域(temporal)上的耦合，从而抑制了对中心契约管理的需求。</p><blockquote><p>多种编程语言，多种选择可能<br>做为一个平台，JVM的发展仅仅是一个将各种编程语言混合到一个通用平台的最新例证。近十年以来，通过在平台外层实现更高层次的编程语言，来利用更高层次的抽象，已经成为一个普遍做法。同样，在平台底层以更低层次的编程语言编写性能敏感的代码也很普遍。然而，许多单块系统并不需要这种级别的性能优化，另外DSL和更高层次的抽象也不常用（这令我们感到失望）。相反，许多单块应用通常就使用单一编程语言，并且有对所使用的技术数量进行限制的趋势[10]。</p></blockquote><p>或许去中心化地治理技术的极盛时期，就是亚马逊的“谁构建，谁运行”的理念开始普及的时候。各个团队负责其所构建的软件的所有工作，其中包括7x24地对软件进行运维。“将运维这一级别的职责下放到团队”这种做法，目前绝对不是主流。但是我们确实看到越来越多的公司，将运维的职责交给各个开发团队。Netflix就是已经形成这种风气的另一个组织[11]。避免每天凌晨3点被枕边的寻呼机叫醒，无疑是在程序员编写代码时令其专注质量的强大动力。而这些想法，与那些传统的中心化技术治理的模式具有天壤之别。<br><a name="Wxa1t"></a></p><h4 id="特性六：“去中心化”地管理数据"><a href="#特性六：“去中心化”地管理数据" class="headerlink" title="特性六：“去中心化”地管理数据"></a>特性六：“去中心化”地管理数据</h4><p>去中心化地管理数据，其表现形式多种多样。从最抽象的层面看，这意味着各个系统对客观世界所构建的概念模型各不相同。当在一个大型的企业中进行系统集成时，这是一个常见的问题。比如对于“客户”这个概念，从销售人员的视角看，就与从支持人员的视角看有所不同。从销售人员的视角所看到的一些被称之为“客户”的事物，或许在支持人员的视角中根本找不到。而那些在两个视角中都能看到的事物，或许各自具有不同的属性。更糟糕的是，那些在两个视角中具有相同属性的事物，或许在语义上有微妙的不同。<br>上述问题在不同的应用程序之间经常出现，同时也会出现在这些应用程序内部，特别是当一个应用程序被分成不同组件时就会出现。思考这类问题的一个有效方法，就是使用领域驱动设计（Domain-Driven Design, DDD）中的“<a href="https://link.jianshu.com?t=https://martinfowler.com/bliki/BoundedContext.html" rel="external nofollow noopener noreferrer" target="_blank">限界上下文</a>”（Bounded Context）的概念。DDD将一个复杂的领域划分为多个限界上下文，并且将其相互之间的关系用图画出来。这一划分过程对于单块和微服务架构两者都是有用的，而且就像前面有关“业务功能”一节中所讨论的那样，在服务和各个限界上下文之间所存在的自然的联动关系，有助于澄清和强化这种划分。</p><blockquote><p><strong>“实战检验”的标准与“强制执行”的标准</strong><br>微服务的下述做法有点泾渭分明的味道，即他们趋向于避开被那些企业架构组织所制定的硬性实施标准，而愉快地使用甚至传播一些开放标准，比如HTTP、ATOM和其他微格式的协议。<br>这里的关键区别是，这些标准是如何被制定以及如何被实施的。像诸如IETF这样的组织所管理的各种标准，只有达到下述条件才能称为标准，即该标准在全球更广阔的地区有一些正在运行的实现案例，而且这些标准经常源自一些成功的开源项目。<br>这些标准组成了一个世界，它区别于来自下述另一个世界的许多标准，即企业世界。企业世界中的标准，经常由这样特点的组织来开发，即缺乏用较新技术进行编程的经验，或受到供应商的过度影响。</p></blockquote><p>如同在概念模型上进行去中心化的决策一样，微服务也在数据存储上进行去中心化的决策。尽管各个单块应用更愿意在逻辑上各自使用一个单独的数据库来持久化数据，但是各家企业往往喜欢一系列单块应用共用一个单独的数据库——许多这样的决策是被供应商的各种版权商业模式所驱动出来的。微服务更喜欢让每一个服务来管理其自有数据库。其实现可以采用相同数据库技术的不同数据库实例，也可以采用完全不同的数据库系统。这种方法被称作“<a href="https://link.jianshu.com?t=https://martinfowler.com/bliki/PolyglotPersistence.html" rel="external nofollow noopener noreferrer" target="_blank">多语种持久化</a>”(Polyglot Persistence)。在一个单块系统中也能使用多语种持久化，但是看起来这种方法在微服务中出现得更加频繁。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/webp/328984/1563434196033-49bdd7a6-7511-4213-9b03-c548ed2d572e.webp#align=left&display=inline&height=620&originHeight=620&originWidth=1000&size=0&status=done&width=1000" alt></p><p><span class="s1">图4：微服务更喜欢让每一个服务来管理其自有数据库</span><br>在各个微服务之间将数据的职责进行“去中心化”的管理，会影响软件更新的管理。处理软件更新的常用方法，是当更新多个资源的时候，使用事务来保证一致性。这种方法经常在单块系统中被采用。<br>像这样使用事务，有助于保持数据一致性。但是在时域上会引发明显的耦合，这样一来，在多个服务之间处理事务时会出现一致性问题。分布式事务实现难度之大是不必多言的。为此，微服务架构更强调在各个服务之间进行<a href="https://link.jianshu.com?t=http://www.enterpriseintegrationpatterns.com/ramblings/18_starbucks.html" rel="external nofollow noopener noreferrer" target="_blank">“无事务”的协调</a>。这源自微服务社区明确地认识到下述两点，即数据一致性可能只要求数据在最终达到一致，并且一致性问题能够通过补偿操作来进行处理。<br>对于许多开发团队来说，选择这种方式来管理数据的“非一致性”，是一个新的挑战。但这通常也符合在商业上的实践做法。通常情况下，为了快速响应需求，商家们都会处理一定程度上的数据“非一致性”，通过做某种反向过程来进行错误处理。只要修复错误的成本低于“保持更大的数据一致性却导致丢了生意所产生”的成本相比，那么进行这种“非一致性”地数据管理就是值得的。<br><a name="rRtF4"></a></p><h4 id="特性七：“基础设施”自动化"><a href="#特性七：“基础设施”自动化" class="headerlink" title="特性七：“基础设施”自动化"></a>特性七：“基础设施”自动化</h4><p>基础设施自动化技术在过去几年里已经得到长足的发展。云的演进，特别是AWS的发展，已经降低了构建、部署和运维微服务的操作复杂性。<br>许多使用微服务构建的产品和系统，正在被这样的团队所构建，即他们都具备极其丰富的“<a href="https://link.jianshu.com?t=http://martinfowler.com/bliki/ContinuousDelivery.html" rel="external nofollow noopener noreferrer" target="_blank">持续交付</a>”和其前身“<a href="https://link.jianshu.com?t=https://martinfowler.com/articles/continuousIntegration.html" rel="external nofollow noopener noreferrer" target="_blank">持续集成</a>”的经验。用这种方法构建软件的各个团队，广泛采用了基础设施的自动化技术。如下图的构建流水线所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/webp/328984/1563434196060-eafb45f7-a7fe-4d60-ab17-303e5e7c557c.webp#align=left&display=inline&height=375&originHeight=375&originWidth=1000&size=0&status=done&width=1000" alt></p><p>图5：基本的构建流水线<br>由于本文并不是一篇有关持续交付的文章，所以下面仅提请大家注意两个持续交付的关键特点。为了尽可能地获得对正在运行的软件的信心，需要运行大量的自动化测试。让可工作的软件达到“晋级”(Promotion)状态、从而“推上”流水线，就意味着可以在每一个新的环境中，对软件进行自动化部署。<br>一个单块应用程序，能够相当愉快地在上述各个环境中，被构建、测试和推送。其结果是，一旦在下述工作中进行了投入，即针对一个单块系统将其通往生产环境的通道进行自动化，那么部署更多的应用系统似乎就不再可怕。记住，持续交付的目的之一，是让“部署”工作变得“无聊”。所以不管是一个还是三个应用系统，只要部署工作依旧很“无聊”，那么就没什么可担心的了[12]。</p><blockquote><p><strong>让“沿着正确的方向做事”更容易</strong><br>那些因实现持续交付和持续集成所增加的自动化工作的副产品，是一些对开发和运维人员有用的工具。现在，能完成下述工作的工具已经相当常见了，即创建工件(artefacts)、管理代码库、启动一些简单的服务、或增加标准的监控和日志功能。Web上最好的例子可能是Netflix提供的一套<a href="https://link.jianshu.com?t=http://netflix.github.io/" rel="external nofollow noopener noreferrer" target="_blank">开源工具集</a>，但也有其他一些好工具，包括我们已经广泛使用的<a href="https://link.jianshu.com?t=http://dropwizard.codahale.com/" rel="external nofollow noopener noreferrer" target="_blank">Dropwizard</a>。</p></blockquote><p>我们所看到的各个团队在广泛使用基础设施自动化实践的另一个领域，是在生产环境中管理各个微服务。与前面我们对比单块系统和微服务所说的正相反，只要部署工作很无聊，那么在这一点上单块系统和微服务就没什么区别。然而，两者在运维领域的情况却截然不同。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/webp/328984/1563434196137-c044b47a-d05e-4ea9-b364-7e4f55929607.webp#align=left&display=inline&height=583&originHeight=583&originWidth=1000&size=0&status=done&width=1000" alt></p><p>图6：两者的模块部署经常会有差异<br><a name="Vsygu"></a></p><h4 id="特性八：“容错”设计"><a href="#特性八：“容错”设计" class="headerlink" title="特性八：“容错”设计"></a>特性八：“容错”设计</h4><p>使用各个微服务来替代组件，其结果是各个应用程序需要被设计的能够容忍这些服务所出现的故障。如果服务提供方不可用，那么任何对该服务的调用都会出现故障。客户端要尽可能优雅地应对这种情况。与一个单块设计相比，这是一个劣势。因为在处理这种情况时会引入额外的复杂性。为此，各个微服务团队在不断地反思：这些服务故障是如何影响用户体验的。Netflix公司所研发的开源测试工具<a href="https://link.jianshu.com?t=https://github.com/Netflix/SimianArmy" rel="external nofollow noopener noreferrer" target="_blank">Simian Army</a>，能够诱导服务发生故障，甚至能诱导一个数据中心在工作日发生故障，来测试该应用的弹性和监控能力。<br>这种在生产环境中所进行的自动化测试，足以让大多数运维组织兴奋得浑身颤栗，就像即将迎来一周的长假那样。这并不是说单块架构风格不能构建先进的监控系统——只是根据我们的经验，这在单块系统中并不常见罢了。</p><blockquote><p><strong>“断路器”与“可随时上线的代码”</strong><br>“<a href="https://link.jianshu.com?t=https://martinfowler.com/bliki/CircuitBreaker.html" rel="external nofollow noopener noreferrer" target="_blank">断路器</a>”(Circuit Breaker)一词与其他一些模式一起出现在《<a href="https://link.jianshu.com?t=https://www.amazon.com/gp/product/B00A32NXZO?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=B00A32NXZO" rel="external nofollow noopener noreferrer" target="_blank">Release It!</a>》一书中，例如隔板(Bulkhead)和超时(Timeout)。当构建彼此通信的应用系统时，将这些模式加以综合运用就变得至关重要。Netflix公司的这篇<a href="https://link.jianshu.com?t=http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html" rel="external nofollow noopener noreferrer" target="_blank">很精彩的博客</a>解释了这些模式是如何应用的。</p></blockquote><p>因为各个服务可以在任何时候发生故障，所以下面两件事就变得很重要，即能够快速地检测出故障，而且在可能的情况下能够自动恢复服务。各个微服务的应用都将大量的精力放到了应用程序的实时监控上，来检查“架构元素指标”（例如数据库每秒收到多少请求）和“业务相关指标”（例如系统每分钟收到多少订单）。当系统某个地方出现问题，语义监控系统能提供一个预警，来触发开发团队进行后续的跟进和调查工作。<br>这对于一个微服务架构是尤其重要的，因为微服务对于服务编制(choreography)和<a href="https://link.jianshu.com?t=https://martinfowler.com/eaaDev/EventCollaboration.html" rel="external nofollow noopener noreferrer" target="_blank">事件协作</a>的偏好，会导致“突发行为”。尽管许多权威人士对于偶发事件的价值持积极态度，但事实上，“突发行为”有时是一件坏事。在能够快速发现有坏处的“突发行为”并进行修复方面，监控是至关重要的。<br>单块系统也能构建的像微服务一样来实现透明的监控系统——实际上，它们也应该如此。差别是，绝对需要知道那些运行在不同进程中的服务，在何时断掉了。而如果在同一个进程内使用软件库的话，这种透明的监控系统就用处不大了。</p><blockquote><p><strong>“同步调用”有害</strong><br>一旦在一些服务之间进行多个同步调用，就会遇到宕机的乘法效应。简而言之，这意味着整个系统的宕机时间，是每一个单独模块各自宕机时间的乘积。此时面临着一个选择：是让模块之间调用异步，还是去管理宕机时间？在<a href="https://link.jianshu.com?t=https://www.theguardian.com/international" rel="external nofollow noopener noreferrer" target="_blank">英国卫报网站</a>，他们在新平台上实现了一个简单的规则——每一个用户请求都对应一个同步调用。然而在Netflix公司，他们重新设计的平台API将异步性构建到API的机制(fabric)中。</p></blockquote><p>那些微服务团队希望在每一个单独的服务中，都能看到先进的监控和日志记录装置。例如显示“运行/宕机”状态的仪表盘，和各种运维、业务相关的指标。另外我们经常在工作中会碰到这样一些细节，即断路器的状态、当前的吞吐率和延迟，以及其他一些例子。<br><a name="O1gmu"></a></p><h4 id="特性九：“演进式”设计"><a href="#特性九：“演进式”设计" class="headerlink" title="特性九：“演进式”设计"></a>特性九：“演进式”设计</h4><p>那些微服务的从业者们，通常具有演进式设计的背景，而且通常将服务的分解，视作一个额外的工具，来让应用开发人员能够控制应用系统中的变化，而无须减少变化的发生。控制变化并不一定意味着要减少变化——在正确的态度和工具的帮助下，软件中的变化也可以发生得频繁、快速且得到良好的控制。<br>每当要试图将软件系统分解为各个组件时，就会面临这样的决策，即如何进行切分——我们决定切分应用系统时应该遵循的原则是什么？一个组件的关键属性，是具有独立更换和升级的特点[13]——这意味着，需要寻找这些点，即想象着能否在其中一个点上重写该组件，而无须影响该组件的其他合作组件。事实上，许多做微服务的团队会更进一步，他们明确地预期许多服务将来会报废，而不是守着这些服务做长期演进。<br>英国卫报网站是一个好例子。原先该网站是一个以单块系统的方式来设计和构建的应用系统，然而它已经开始向微服务方向进行演进了。原先的单块系统依旧是该网站的核心，但是在添加新特性时他们愿意以构建一些微服务的方式来进行添加，而这些微服务会去调用原先那个单块系统的API。当开发那些本身就带有临时性特点的新特性时，这种方法就特别方便，例如开发报道一个体育赛事的专门页面。当使用一些快速的开发语言时，这样的网站页面就能被快速地整合起来。而一旦赛事结束，这样页面就可以被删除。在一个金融机构中，我们已经看到了一些相似的做法，即针对一个市场机会，一些新的服务可以被添加进来。然后在几个月甚至几周之后，这些新服务就作废了。<br>这种强调“可更换性”的特点，是模块化设计一般性原则的一个特例，通过“变化模式”(pattern of change)[14]来驱动模块化的实现。大家都愿意将那些能在同时发生变化的东西，放到同一个模块中。系统中那些很少发生变化的部分，应该被放到不同的服务中，以区别于那些正在经历大量变动(churn)的部分。当发现两个服务需要被同时、反复变更，就意味着它们两个需要被合并。<br>把一个个组件放入一个个服务中，提高了软件发布精细化的程度。对于一个单块系统，任何变化都需要做一次整个应用系统的全量构建和部署。然而，对于一个个微服务来说，只需要重新部署修改过的那些服务就够了。这能简化并加快发布过程。但缺点是：必须要考虑当一个服务发生变化时，依赖它并对其进行消费的其他服务将无法工作。传统的集成方法是使用版本化来解决这个问题。但在微服务世界中，大家更喜欢<a href="https://link.jianshu.com?t=https://martinfowler.com/articles/enterpriseREST.html#versioning" rel="external nofollow noopener noreferrer" target="_blank">将版本化作为最后万不得已的手段</a>来使用。我们可以通过下述方法来避免许多版本化的工作，即把各个服务设计得尽量能够容错，来应对其所依赖的服务所发生的变化。<br><a name="WLEGY"></a></p><h3 id="未来的方向是“微服务”吗？"><a href="#未来的方向是“微服务”吗？" class="headerlink" title="未来的方向是“微服务”吗？"></a>未来的方向是“微服务”吗？</h3><p>我们写这篇文章的主要目的，是解释有关微服务的主要思路和原则。在花了一点时间做了这件事后，我们清楚地认识到，微服务架构风格是一个重要的理念——在研发企业应用系统时，值得对它进行认真考虑。我们最近已经使用这种风格构建了一些系统，并且了解到其他一些团队也赞同并正在使用这种方法。<br>我们所了解到的那些在某种程度上可以被称作这种架构风格的实践先驱包括：亚马逊、Netflix、<a href="https://link.jianshu.com?t=https://www.theguardian.com/international" rel="external nofollow noopener noreferrer" target="_blank">英国卫报</a>、<a href="https://link.jianshu.com?t=https://gds.blog.gov.uk/" rel="external nofollow noopener noreferrer" target="_blank">英国政府数字化服务中心</a>、realestate.com.au、Forward和comparethemarket.com。2013年的技术大会圈子充满了各种各样的、正在转向可归类为微服务的公司案例——包括Travis CI。另外还有大量的组织，它们长期以来一直在做着我们认为可以归类为微服务的产品，却从未使用过这个名字（这通常被标记为SOA——尽管正如我们所说，SOA会表现出各种自相矛盾的形式[15]）。<br>尽管有这些正面的经验，但这并不意味着我们确信微服务是软件架构未来的方向。尽管到目前为止，与单块应用系统相比，我们对于所经历过的微服务的评价是积极的，但是我们也意识到这样的事实，即能供我们做出完整判断的时间还不够长。<br>通常，架构决策所产生的真正效果，只有在该决策做出若干年后才能真正显现。我们已经看到由带着强烈的模块化愿望的优秀团队所做的一些项目，最终构建出一个单块架构，并在几年之内不断腐化。许多人认为，如果使用微服务就不大可能出现这种腐化，因为服务的边界是明确的，而且难以随意搞乱。然而，对于那些开发时间足够长的各种系统，除非我们已经见识得足够多，否则我们无法真正评价微服务架构是如何成熟的。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/webp/328984/1563434196062-400fc55b-1aac-4f20-8a52-05dcbf9409cd.webp#align=left&display=inline&height=891&originHeight=891&originWidth=641&size=0&status=done&width=641" alt></p><p>我们的同事Sam Newman花了2014年的大部分时间撰写了<a href="https://link.jianshu.com?t=https://www.amazon.com/gp/product/1491950358?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1491950358" rel="external nofollow noopener noreferrer" target="_blank">一本书</a>，来记述我们构建微服务的经验。如果想对这个话题进行更深入的了解，下一步就应该是阅读这本书。<br>有人觉得微服务或许很难成熟起来，这当然是有原因的。在组件化上所做的任何工作的成功度，取决于软件与组件的匹配程度。准确地搞清楚某个组件的边界位置应该出现在哪里，是一件困难的工作。演进式设计承认难以对边界进行正确定位，所以它将工作的重点放到了易于对边界进行重构之上。但是当各个组件成为各个进行远程通信的服务后，比起在单一进程内调用各个软件库，此时的重构就变得更加困难。跨越服务边界的代码移动就变得困难起来。接口的任何变化，都需要在其各个参与者之间进行协调。向后兼容的层次也需要被添加进来。测试也会变得更加复杂。<br>另一个问题是，如果这些组件不能干净利落地组合成一个系统，那么所做的一切工作，仅仅是将组件内的复杂性转移到组件之间的连接之上。这样做的后果，不仅仅是将复杂性搬了家，它还将复杂性转移到那些不再明确且难以控制的边界之上。在观察一个小型且简单的组件内部时，人们很容易觉得事情已经变得更好了，然而他们却忽视了服务之间杂乱的连接。<br>最后，还要考虑团队成员的技能水平。新技术往往会被技术更硬的团队所采用。对于技术更加过硬的团队而更有效的一项技术，不一定适用于技术略逊一筹的团队。我们已经看到大量这样的案例，那些技术略逊一筹的团队构建出了杂乱的单块架构。当这种杂乱发生到微服务身上时，会出现什么情况？这需要花时间来观察。一个糟糕的团队，总会构建一个糟糕的系统——在这种情况下，很难讲微服务究竟是减少了杂乱，还是让事情变得更糟。<br>我们听到一个合理的<a href="https://link.jianshu.com?t=https://martinfowler.com/bliki/MonolithFirst.html" rel="external nofollow noopener noreferrer" target="_blank">说法</a>：不要一上来就以微服务架构做为起点。相反，要用一个单块系统做为起点，并保持其模块化。当这个单块系统出现了问题后，再将其分解为微服务。（尽管这个<a href="https://link.jianshu.com?t=https://martinfowler.com/articles/dont-start-monolith.html" rel="external nofollow noopener noreferrer" target="_blank">建议</a>并不理想，因为一个良好的单一进程内的接口，通常不是一个良好的服务接口。）<br>因此，我们持谨慎乐观的态度来撰写此文。到目前为止，我们已经看到足够多的有关微服务风格的内容，并且觉得这是一条值得去跋涉的道路。我们不能肯定地说，道路的尽头在哪里。但是，软件开发的挑战之一，就是只能基于“目前手上拥有但还不够完善”的信息来做出决策。<br>若欲获取最新参考资料列表以得到更多信息，请参见<a href="https://link.jianshu.com?t=http://martinfowler.com/microservices/" rel="external nofollow noopener noreferrer" target="_blank">微服务资源指南：http://martinfowler.com/microservices/</a>。<br>注：<br>[1]. 2011年5月在威尼斯附近的一个软件架构工作坊中，大家开始讨论“微服务”这个术语，因为这个词可以描述参会者们在架构领域进行探索时所见到的一种通用的架构风格。2012年5月，这群参会者决定将“微服务”作为描述这种架构风格的最贴切的名字。在2012年3月波兰的克拉科夫市举办的“33rd Degree”技术大会上，本文作者之一James在其“<a href="https://link.jianshu.com?t=http://2012.33degree.org/talk/show/67" rel="external nofollow noopener noreferrer" target="_blank">Microservices - Java, the Unix Way</a>”演讲中以案例的形式谈到了这些微服务的观点，与此同时，<a href="https://link.jianshu.com?t=http://www.slideshare.net/fredgeorge/micro-service-architecure" rel="external nofollow noopener noreferrer" target="_blank">Fred George</a>也表达了同样的观点。Netflix公司的Adrian Cockcroft将这种方法描述为“细粒度的SOA”，并且作为先行者和本文下面所提到的众人已经着手在Web领域进行了实践——Joe Walnes, Dan North, Evan Botcher 和 Graham Tackley。<br>[2]. “单块”(monolith)这个术语已经被Unix社区使用一段时间了。它出现在The Art of Unix Programming一书中，来描述那些变得庞大的系统。<br>[3]. 许多面向对象的设计者，包括我们自己，都使用领域驱动设计中“service object”这个术语，来描述那种执行一段未被绑定到一个entity对象上的重要逻辑过程的对象。这不同于本文所讨论的”service”的概念。可悲的是，service这个术语同时具有这两个含义，我们必须忍受这样的多义词。<br>[4]. 我们认为一个应用系统是一个社会性的构建单元，来将一个代码库、功能组和资金体（body of funding）结合起来。<br>[5]. 原始论文参见梅尔文•康威的网站：<a href="https://link.jianshu.com?t=http://www.melconway.com/Home/Committees_Paper.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.melconway.com/Home/Committees_Paper.html</a><br>[6]. 在极度强调高效性(Scale)的情况下，一些组织经常会使用一些二进制的消息发送协议——例如protobuf。即使是这样，这些系统仍然会呈现出“智能端点和傻瓜管道”的特点——来在易读性(transparency)与高效性之间取得平衡。当然，大多数Web属性和绝大多数企业并不需要作出这样的权衡——获得易读性就已经是一个很大的胜利了。<br>[7]. 忍不住要提一下Jim Webber的说法：ESB表示Egregious Spaghetti Box（一盒极烂的意大利面条）。<br>[8]. Netflix让SOA与微服务之间的联系更加明确——直到最近这家公司还将他们的架构风格称为“细粒度的SOA”。<br>[9]. “YAGNI” 或者 “You Aren’t Going To Need It”（你不会需要它）是极限编程的一条原则和劝诫，指的是“除非到了需要的时候，否则不要添加新功能”。<br>[10]. 单块系统使用单一编程语言，这样讲有点言不由衷——为了在今天的Web上构建各种系统，可能要了解JavaScript、XHTML、CSS、服务器端的编程语言、SQL和一种ORM的方言。很难说只有一种单一编程语言，但是我们的意思你是懂得的。<br>[11]. Adrian Cockcroft在他2013年11月于Flowcon技术大会所做的一次精彩的演讲中，特别提到了“开发人员自服务”和“开发人员运行他们写的东西”（原文如此）。<br>[12]. 这里我们又有点言不由衷了。 很明显，在更复杂的网络拓扑里，部署更多的服务，会比部署一个单独的单块系统要更加困难。幸运的是，有一些模式能够减少其中的复杂性——但对于工具的投资还是必须的。<br>[13]. 事实上，Dan North将这种架构风格称作“可更换的组件架构”，而不是微服务。因为这看起来似乎是在谈微服务特性的一个子集，所以我们选择将其归类为微服务。<br>[14]. Kent Beck在《实现模式》(Implementation Patterns)一书中，将其作为他的一条设计原则而强调出来。<br>[15]. 当SOA这个词在本世纪初刚刚出现时，有人曾说：“我们很多年以来一直是这样做的。”有一派观点说，SOA这种风格，将企业级计算早期COBOL程序通过数据文件来进行通信的方式，视作自己的“根”。在另一个方向上，有人说“Erlang编程模型”与微服务是同一回事，只不过它被应用到一个企业应用的上下文中去了。<br>译者：ThoughtWorks 伍斌<br>链接：<a href="https://www.jianshu.com/p/4821a29fa998" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/4821a29fa998</a><br>来源：简书<br>如侵权，请联系博主，立即删除。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务的文章，还是以Martin Fowler的&lt;a href=&quot;https://martinfowler.com/articles/microservices.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Microservices&lt;/a&gt;一文为经典。国内已经有很多翻译。本文转载了ThoughtWorks 伍斌的翻译，可能会有少量的语言调整。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="https://www.ikhan.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="microservices" scheme="https://www.ikhan.top/tags/microservices/"/>
    
  </entry>
  
  <entry>
    <title>docker 使用记录</title>
    <link href="https://www.ikhan.top/posts/docker-using-experience.html"/>
    <id>https://www.ikhan.top/posts/docker-using-experience.html</id>
    <published>2015-08-09T01:23:20.000Z</published>
    <updated>2020-03-15T10:05:21.865Z</updated>
    
    <content type="html"><![CDATA[<p>之前也有了解和学习过 docker ，但没有真正的使用。这次借助搭建 GitLab 服务器的机会，使用了 docker，觉得果然是方便了许多。在这儿记录下大概的使用过程和体会。</p><a id="more"></a><h2 id="接触"><a href="#接触" class="headerlink" title="接触"></a>接触</h2><p>docker 很早就有了解，却一直没怎么有正儿八经的场景把玩一下。</p><p>刚开始学习 docker 的使用，是从 gitbook <a href="https://www.gitbook.com/book/yeasy/docker_practice/details" rel="external nofollow noopener noreferrer" target="_blank">https://www.gitbook.com/book/yeasy/docker_practice/details</a> 上面。</p><p>当然，这里面每一章讲的比较少，具体的命令和一些操作的含义可能还是要看官方文档：<a href="http://docs.docker.com/" rel="external nofollow noopener noreferrer" target="_blank">http://docs.docker.com/ </a> </p><p>docker 的目标是轻量级的操作系统虚拟化解决方案，现在已经做得很棒了。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>使用 docker，我觉得主要得理解如下几个核心概念：</p><ul><li>仓库</li><li>镜像</li><li>容器</li></ul><p>其实，仓库的概念很好理解，可以类比 maven 的中央仓库等。</p><p>镜像和容器就要细想一下了。镜像就好比打包好的一个系统模板，可以认为是系统安装光盘一样的东西。而容器就是安装好的系统。用什么样的安装光盘就会安装出来什么样的系统。<br>镜像是“静态”的，不可运行的。可以以它为模板创建很多容器。而容器是“动态”的，可运行的。状态有启停的切换。也可以用把修改后的容器制作成新的镜像“模板”。</p><h2 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h2><h3 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h3><p>安装可以参考 <a href="https://docs.docker.com/installation/#installation" rel="external nofollow noopener noreferrer" target="_blank">官方的安装指南</a> 。</p><p>CentOS 7 下面只需要运行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> docker</span><br></pre></td></tr></table></figure><p>然后启动 Docker 服务，设置开机启动：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="keyword">start</span> docker</span><br><span class="line">sudo systemctl <span class="keyword">enable</span> docker</span><br></pre></td></tr></table></figure><h3 id="配置-mirror-仓库"><a href="#配置-mirror-仓库" class="headerlink" title="配置 mirror 仓库"></a>配置 mirror 仓库</h3><p>由于网络原因，Docker 官方的镜像仓库不太好下载。<br>所以，我会配置国内的镜像，目前使用 <a href="https://www.daocloud.io/" rel="external nofollow noopener noreferrer" target="_blank">DaoCloud</a>的免费<a href="https://dashboard.daocloud.io/mirror" rel="external nofollow noopener noreferrer" target="_blank">镜像仓库</a>。当然，这个是有限制的，每注册用户每月 2W请求数等。<br>如果是注册用户，在上面地址中有各个系统的配置介绍。如果有其他好的镜像欢迎大家告诉我，先谢谢了。</p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>下载镜像 ： <code>sudo docker pull</code><br>查看镜像列表：<code>sudo docker images</code><br>删除镜像 : <code>sudo docker rmi</code><br>用镜像创建容器：<code>sudo docker creat</code><br>用镜像创建容器并启动：<code>sudo docker run</code><br>查看容器列表：<code>sudo docker ps</code><br>停止容器：<code>sudo docker stop</code><br>启动容器：<code>sudo docker start</code><br>删除容器：<code>sudo docker rm</code>  </p><p>还有其他等一些命令，可以通过 <code>sudo docker help</code>来查看，或者通过<a href="https://docs.docker.com/docker/reference/commandli" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a> 查看更详细的文档。</p><h2 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h2><p>这次通过 docker 很方便很快速的搭建好了 GitLab 服务器。<br>个性化的配置都可以通过参数指定。实际上，大部分的时间都是镜像下载的时间。  </p><p>普通的使用者不用关心镜像内的细节，不用关注各种软件如何安装和配置，不用关心现有环境对目标安装过程中的影响，也不用担心目标环境对当前环境的破坏。<br>而且，由于我的特殊需求，在原 Dockerfile 的基础上做了一些特定的修改，然后 <code>docker build</code>一下，就得到了我想要的镜像。我可根据这个镜像随时再创建新的镜像或运行容器，并且分享给别人让他瞬间拥有和我一样的环境。这样的成果只需很少的操作，真的很棒。</p><p>考虑以后利用 docker 帮助我们提高开发、测试、运维等环境问题。保持关注和学习。</p><p>这篇写的仓促，只是做个记录，更多内容待以后有丰富的经验和更深刻的体会再说吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前也有了解和学习过 docker ，但没有真正的使用。这次借助搭建 GitLab 服务器的机会，使用了 docker，觉得果然是方便了许多。在这儿记录下大概的使用过程和体会。&lt;/p&gt;
    
    </summary>
    
      <category term="devops" scheme="https://www.ikhan.top/categories/devops/"/>
    
      <category term="容器" scheme="https://www.ikhan.top/categories/devops/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="docker" scheme="https://www.ikhan.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>使用 Docker 安装 GitLab + 汉化版</title>
    <link href="https://www.ikhan.top/posts/install-gitlab-zh-with-docker.html"/>
    <id>https://www.ikhan.top/posts/install-gitlab-zh-with-docker.html</id>
    <published>2015-08-08T13:13:15.000Z</published>
    <updated>2020-03-15T10:05:21.865Z</updated>
    
    <content type="html"><![CDATA[<p>GitLab 在众多 Git 服务器中算是颜值和能力都不错的。但是，有一个缺点就是安装不便。<br>当然，也有一键安装包，但安装过程中仍有可能出问题，而且维护升级也不简单。这次搭建新的 Git 服务器，尝试通过 docker 安装，效果非常好。</p><a id="more"></a><h2 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h2><p>宿主服务器是 Centos 7。之上只安装了 Git 和 docker。docker 版本是 1.6.2 。</p><h2 id="docker-镜像安装-GitLab"><a href="#docker-镜像安装-GitLab" class="headerlink" title="docker 镜像安装 GitLab"></a>docker 镜像安装 GitLab</h2><p>GitLab 镜像使用的是 <a href="https://github.com/sameersbn/docker-gitlab" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/sameersbn/docker-gitlab</a> (如果需要汉化版，请先看下面的汉化安装)。安装的时候选用的最高版本 7.13.2。<br>另外，这个镜像里面不包含 redis 和 数据库。所以还使用了另外两个镜像：</p><ul><li>redis： <a href="https://github.com/sameersbn/docker-redis" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/sameersbn/docker-redis</a></li><li>postgresql： <a href="https://github.com/sameersbn/docker-postgresql" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/sameersbn/docker-postgresql</a></li></ul><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>下载镜像比较简单</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull sameersbn/redis:latest</span><br><span class="line">sudo docker pull sameersbn/postgresql:<span class="number">9.4</span><span class="number">-2</span></span><br><span class="line">sudo docker pull sameersbn/gitlab:<span class="number">7.13</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>其中 gitlab 的镜像比较大，有 600+M， 其他两个在 200M 左右。下载情况就靠网络了。我在使用docker镜像的情况下都失败了一次。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装实际上比较简单。就是 <code>docker run ……</code> 就好了。主要是注意参数配置。</p><h4 id="PostgreSql"><a href="#PostgreSql" class="headerlink" title="PostgreSql"></a><em>PostgreSql</em></h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p <span class="regexp">/srv/</span>docker<span class="regexp">/gitlab/</span>postgresql</span><br><span class="line">sudo chcon -Rt svirt_sandbox_file_t <span class="regexp">/srv/</span>docker<span class="regexp">/gitlab/</span>postgresql</span><br><span class="line"></span><br><span class="line">sudo docker run --name gitlab-postgresql -tid \</span><br><span class="line">    -e <span class="string">'DB_NAME=gitlabhq_production'</span> \</span><br><span class="line">    -e <span class="string">'DB_USER=gitlab'</span> -e <span class="string">'DB_PASS=password'</span> \</span><br><span class="line">    -v <span class="regexp">/srv/</span>docker<span class="regexp">/gitlab/</span><span class="string">postgresql:</span><span class="regexp">/var/</span>lib/postgresql \</span><br><span class="line">    sameersbn/<span class="string">postgresql:</span><span class="number">9.4</span><span class="number">-2</span></span><br></pre></td></tr></table></figure><p>命令中主要注意的是两点：</p><ul><li>chcon ··· 主要是考虑 selinux 开启的情况，这个大家看情况执行。</li><li>docker run 命令中中的 -v 是为了将宿主服务器的目录挂载到 docker 内，为了持久化数据，下面的其他容器也一样。</li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><em>Redis</em></h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /srv/docker/gitlab/redis</span><br><span class="line">sudo chcon -Rt svirt_sandbox_file_t /srv/docker/gitlab/redis</span><br><span class="line"></span><br><span class="line">sudo docker run --name gitlab-redis -tid \</span><br><span class="line">    -v /srv/docker/gitlab/<span class="symbol">redis:</span>/var/<span class="class"><span class="keyword">lib</span>/<span class="title">redis</span> \</span></span><br><span class="line">    sameersbn/<span class="symbol">redis:</span>latest</span><br></pre></td></tr></table></figure><p>这个和上面差不多，redis 没做特殊配置。</p><h4 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a><em>GitLab</em></h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /srv/docker/gitlab/gitlab</span><br><span class="line">sudo chcon -Rt svirt_sandbox_file_t /srv/docker/gitlab/gitlab</span><br><span class="line"></span><br><span class="line">sudo docker run --name gitlab -tid <span class="string">\</span></span><br><span class="line">    --link gitlab-postgresql:postgresql --link gitlab-redis:redisio <span class="string">\</span></span><br><span class="line">    -p <span class="number">10022</span>:<span class="number">22</span> -p <span class="number">80</span>:<span class="number">80</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'GITLAB_HOST=gitlab.example.cn'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'GITLAB_PORT=80'</span> -e <span class="string">'GITLAB_SSH_PORT=10022'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'GITLAB_BACKUPS=daily'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'GITLAB_BACKUP_TIME=20:00'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'GITLAB_TIMEZONE=Beijing'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'GITLAB_EMAIL=git@example.cn'</span> -e <span class="string">'GITLAB_EMAIL_DISPLAY_NAME=Git'</span> -e <span class="string">'GITLAB_EMAIL_REPLY_TO=noreply@example.cn'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'NGINX_MAX_UPLOAD_SIZE=60m'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'SMTP_DOMAIN=smtp.example.com'</span> -e <span class="string">'SMTP_HOST=smtp.example.com'</span> -e <span class="string">'SMTP_PORT=25'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'SMTP_USER=git@example.cn'</span> -e <span class="string">'SMTP_PASS=example'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'LDAP_ENABLED=true'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'LDAP_HOST=218.104.82.226'</span> -e <span class="string">'LDAP_PORT=389'</span> -e <span class="string">'LDAP_METHOD=plain'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'LDAP_UID=sAMAccountName'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'LDAP_BIND_DN=cn=ldapuser,cn=users,dc=example,dc=com'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'LDAP_PASS=example'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'LDAP_ACTIVE_DIRECTORY=true'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'LDAP_BASE=cn=users,dc=example,dc=com'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'LDAP_BLOCK_AUTO_CREATED_USERS=false'</span> <span class="string">\</span></span><br><span class="line">    -e <span class="string">'GITLAB_GRAVATAR_ENABLED=false'</span> <span class="string">\</span></span><br><span class="line">    -v /srv/docker/gitlab/gitlab:/home/git/data <span class="string">\</span></span><br><span class="line">sameersbn/gitlab:<span class="number">7.13</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure><p>上面的 GitLab 的 docker 命令参数要多一点，主要是其中配置了邮箱和 LDAP 服务器。大家可以参照官方文档自行增删配置。  </p><p>因为这台运行 docker 的宿主服务器就是一台专门为 GitLab 申请的虚拟机，所以后面就没有配置独立IP。<br>直接在命令中通过 <code>-p 10022:22 -p 80:80</code> 指定了服务器的端口映射。</p><p>这里面有一点比较特殊，GitLab 的默认时间是 UTC 时间，所以通过 <code>-e &#39;GITLAB_TIMEZONE=Beijing&#39;</code> 指定了 +8 时区。<br>如果你使用自带的 backup 配置的话也要注意，默认的备份时间 04:00 对应到我们这边实际上是中午 12:00 了。所以我通过 <code>-e &#39;GITLAB_BACKUP_TIME=20:00&#39;</code>指定了备份时间为北京时间的 04:00。当然，这个备份时间大家自己看着调了。</p><p>最后的 GitLab 容器通过 <code>--link gitlab-postgresql:postgresql --link gitlab-redis:redisio</code> link 到 redis 和 postgresql ，所以其他两个容器的 IP 、端口和数据库的配置信息不用指定。镜像中已经做了处理。<br>当然，其他两个容器肯定要比 GitLab 先启动。</p><p>容器启动后等一会（初始化时间）就可以正常访问和配置了。</p><blockquote><p>账户：root<br>密码：5iveL!fe</p></blockquote><h3 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h3><p>开机启动只要把对应的 <code>docker run</code>命令加入到 <code>/etc/rc.d/rc.local</code>中就可以了。需要注意的是，<code>docker</code> 相关命令要在 <code>docker</code> 服务启动的情况下才能运行，所以记得把<code>docker</code>服务加入开机启动。</p><p>rc.local 添加内容：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="literal">start</span> gitlab-redis</span><br><span class="line">docker <span class="literal">start</span> gitlab-postgresql</span><br><span class="line">docker <span class="literal">start</span> gitlab</span><br></pre></td></tr></table></figure><h2 id="汉化安装"><a href="#汉化安装" class="headerlink" title="汉化安装"></a>汉化安装</h2><p>GitLab 的汉化已经有 @larryli 同学在做，仓库地址： <a href="https://gitlab.com/larryli/gitlab" rel="external nofollow noopener noreferrer" target="_blank">https://gitlab.com/larryli/gitlab</a> 。非常感谢他的无私奉献。</p><p>当然，通过我们上面给出的 docker-gitlab 的官方镜像是安装不了汉化版的。所以我在官方镜像的基础上 fork 了一份，将安装的版本改为 @larryli 的汉化版本。</p><p>比较坑的是，由于众所周知的<em>“网络原因”</em>, 在国内 build 镜像会遭遇大量的失败，太打击了。所以一番折腾后又把其他我这边很难下载的东西都改到国内了，浪费了好多时间，简直心酸。修改后的仓库： <a href="https://github.com/clarkhan/docker-gitlab" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/clarkhan/docker-gitlab</a> 。目前没有把 build 的镜像放到 docker 仓库中，大家需要可以自己 clone 下来 build 一下，应该没问题。</p><p>使用汉化的镜像，如上面介绍的一样安装就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitLab 在众多 Git 服务器中算是颜值和能力都不错的。但是，有一个缺点就是安装不便。&lt;br&gt;当然，也有一键安装包，但安装过程中仍有可能出问题，而且维护升级也不简单。这次搭建新的 Git 服务器，尝试通过 docker 安装，效果非常好。&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="https://www.ikhan.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Git" scheme="https://www.ikhan.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/git/"/>
    
    
      <category term="docker" scheme="https://www.ikhan.top/tags/docker/"/>
    
      <category term="gitlab" scheme="https://www.ikhan.top/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu/linux apt-get “Error: Timeout was reached” 解决</title>
    <link href="https://www.ikhan.top/posts/apt-get-error-timeout-was-reached-resolve.html"/>
    <id>https://www.ikhan.top/posts/apt-get-error-timeout-was-reached-resolve.html</id>
    <published>2015-06-11T07:58:05.000Z</published>
    <updated>2020-03-15T10:05:21.865Z</updated>
    
    <content type="html"><![CDATA[<p>忘记是什么时候开始，可能是使用 <code>apt-get upgrade</code> 更新了一大堆软件的原因，后来使用 <code>apt-get update</code> 和 <code>apt-get install</code> 总是遇到 “Error: Timeout was reached” 这样的错误。<br>中文显示应该是 “错误：已到超时限制” 。</p><p>用 Google 大法，经历了曲折的历程后终于解决问题。所以觉得还是有必要记录下，防止小伙伴再走弯路了。</p><a id="more"></a><p>刚开始，找到一篇 wiki ，具体地址忘记了，总之解决问题的方式是：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/etc/apt/apt.conf.d</span></span><br><span class="line"><span class="keyword">echo</span> 'Acquire:<span class="function">:http</span>:<span class="function">:Timeout</span> <span class="string">"600"</span>;' &gt; timeout</span><br></pre></td></tr></table></figure><p>我不知道对其他人有没有用，总之，对我的问题是无效的。</p><p>后来，发现 <a href="http://fanf42.blogspot.com/2014/08/upgrading-to-ubuntu-1404-error-timeout.html" rel="external nofollow noopener noreferrer" target="_blank">这篇博客</a> 记录的问题和我的有些相似。他讲到是由于安装了一个错误的 <code>libapt-pkg4.12</code> 版本引起的问题。<br>于是我在 <a href="http://security.ubuntu.com/ubuntu/pool/main/a/apt/" rel="external nofollow noopener noreferrer" target="_blank">http://security.ubuntu.com/ubuntu/pool/main/a/apt/</a>重新下载安装了最新的 <code>libapt-pkg</code> 。因为最终还是没解决问题，所以详细的步骤就不记录了。</p><p>最后，最后了，这个一定是解决问题了。Google 大法引导我找到了这个页面 <a href="https://bugs.launchpad.net/ubuntu/+source/packagekit/+bug/1001376" rel="external nofollow noopener noreferrer" target="_blank">https://bugs.launchpad.net/ubuntu/+source/packagekit/+bug/1001376</a> Ubuntu 官方的Bug。这个 bug 说明已经被解决。于是乎，参照这个，我又安装了 <code>packagekit</code>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install packagekit</span><br></pre></td></tr></table></figure><p>然后，一切OK了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;忘记是什么时候开始，可能是使用 &lt;code&gt;apt-get upgrade&lt;/code&gt; 更新了一大堆软件的原因，后来使用 &lt;code&gt;apt-get update&lt;/code&gt; 和 &lt;code&gt;apt-get install&lt;/code&gt; 总是遇到 “Error: Timeout was reached” 这样的错误。&lt;br&gt;中文显示应该是 “错误：已到超时限制” 。&lt;/p&gt;
&lt;p&gt;用 Google 大法，经历了曲折的历程后终于解决问题。所以觉得还是有必要记录下，防止小伙伴再走弯路了。&lt;/p&gt;
    
    </summary>
    
      <category term="路漫漫" scheme="https://www.ikhan.top/categories/%E8%B7%AF%E6%BC%AB%E6%BC%AB/"/>
    
      <category term="折腾" scheme="https://www.ikhan.top/categories/%E8%B7%AF%E6%BC%AB%E6%BC%AB/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="linux" scheme="https://www.ikhan.top/tags/linux/"/>
    
      <category term="ubuntu" scheme="https://www.ikhan.top/tags/ubuntu/"/>
    
      <category term="apt-get" scheme="https://www.ikhan.top/tags/apt-get/"/>
    
  </entry>
  
</feed>
